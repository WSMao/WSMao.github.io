[{"categories":null,"contents":"淺談 Github 的身分驗證機制 基於安全及隱私因素，存取 Private 的 Github repository 不管是進行 clone, push, pull 時都需要驗證身分。 而 Public repository 在 clone 時是不用驗證的，直接 clone 就可以了，但 push 時就要驗證你是否為具有開發者身分了。\n不管是早期使用 HTTP/HTTPS 輸入帳號密碼，或者使用 SSH 搭配公私鑰，都是通訊方式及帳戶驗證的手段罷了。 但 SSH 搭配公私鑰讓存取 Github 更安全(不用擔心密碼被破解)且更方便(設定好以後再也不用輸入密碼)。\nHTTPS 搭配帳號密碼的方式沒什麼好說的，需要驗證時會要求你輸入帳號密碼。但，這個方式已經被 Github deprecated，我們應該使用更好的方式，以下就來介紹 SSH 搭配公私鑰的方法。\nGithub 的 SSH key 與 Deploy key 在 Github 或者 Gitlab 中，可以設定 SSH Key 的地方有 2 個，按用途分為 SSH Key 以及 Deploy Key。\n個人 SSH Key: 是屬於整個 Github account 的 global 設定，一台電腦只要設定一次，就能存取所有 Github repositories，適合給該 Github 帳號擁有者設定。 Deploy Key: 是綁定特定 repository 的 SSH 公鑰，用來讓 CI/CD 服務、伺服器或其他環境能夠存取該 repository，但不影響你的 GitHub 上的其他 repositories。 每個 Deploy Key 只能對應一個 repo，不能跨 repo 共用 預設只能讀取（除非勾選 Allow write access） 適用於自動化部署、伺服器存取、CI/CD 系統等場景。 使用 git 指令時 SSH 如何運作 當你使用 git 指令連到 Github 且輸入的是 SSH 格式，則 git 就會嘗試 SSH 安全遠端連線，若需要身分驗證，則會去取用你保存在 local 端的 private key。\nGithub 不允許使用者直接使用 SSH 操作 Github Host，而必須透過 git 指令，再由 git 指令去進行 SSH 操作。\nSSH 的格式為 user@host，對照 git clone 指令格式比如: git clone git@github.com:WSMao/hugo_blog.git 其中\nSSH user: git SSH host: github.com 至於後面的 :WSMao/hugo_blog.git 則是 Github 仿照 scp 格式冒號後面後面接檔案地址。 SSH 連線時選項的決定優先順序大致如下： SSH 指令指定\n若在 ssh 指令中明確指定連線參數，這些會 優先於 config 設定，如 ssh -i ~/.ssh/custom_key git@github.com，其中 -i 選項指定金鑰。 ssh 指令最少可以只輸入 host 即可，如 ssh github.com (前提是 config 設定檔須提供細節)。 ~/.ssh/config\n主要用於簡化 ssh 指令，許多設定可以紀錄在這邊，之後使用 ssh 指令時就不用輸入那麼多細部參數。只要 ssh 指令找不到的參數設定都會到 config 裡找。 如果 ~/.ssh/config 中有針對目標主機 (Host github.com) 指定 IdentityFile，則 SSH 會根據這個設定來選擇金鑰。 config 可以設定不同 repository 使用不同的金鑰，例如： Host github.com-hugo HostName github.com User git IdentityFile ~/.ssh/hugo_key Host github.com-private HostName github.com User git IdentityFile ~/.ssh/private_key SSH Agent\n用於提供 IdentityFile 也就是 private_key 的密碼。 如果 SSH Agent 已經有(ssh-add)載入金鑰(載入時已提供過密碼)，則之後使用 private_key 就不用再輸入密碼。 預設金鑰 (~/.ssh/id_rsa、~/.ssh/id_ed25519)\n若 SSH 連線需要 ssh-key，但 ssh 指令沒有提供，且 ~/.ssh/config 內也沒有指定 IdentityFile，那 SSH 就會嘗試讀取預設的金鑰，如： ~/.ssh/id_rsa (ssh-keygen 預設) ~/.ssh/id_ed25519 (更推薦) 基本上，除非你有很多個 private_key 或者特殊需求需要管理，不然不必使用 agent 或者 config 來設定，使用預設金鑰名稱即可。\nSSH Agent SSH Agent 唯一的作用 就是 暫存私鑰，讓你不用每次輸入密碼。 若有為 private key 設定密碼的話，Agent 可代理管理私鑰密碼，避免每次使用金鑰時都要輸入密碼。只有當 private_key 加入 agent 時需要輸入密碼，只要 agent 持續運行，往後都不用再輸入。 相關 ssh-agent 指令如下:\neval $(ssh-agent): 啟動 ssh-agent\nssh-add \u0026lt;private_key\u0026gt;: 加入 ssh key\nssh-add -l: 列出已加入的 key\nssh-add -D: 移除所有 key\n~/.ssh/config 設定檔 這個檔案可以讓你自訂 SSH 連線方式，可用來簡化 SSH 指令、管理多個 SSH 金鑰。\n簡化 SSH 連線，不用每次都輸入完整的 user/host ip/port/key 等(比如 ssh -i ~/.ssh/id_rsa chris@192.168.1.100 -p 2222)。 可針對不同的主機設定不同的 SSH Key。 可指定預設的 User。 可設定 ProxyJump 來穿透防火牆。 可參考 如何針對不同的-repo-指定不同的-ssh-key\n設定 SSH key 以 Github 帳號擁有者來說，他的身分理當允許存取所有 repositories ，只需要為他的電腦，設置一組 SSH key 並將 public key 加入 Github 即可，往後在這台電腦上進行任何對 Github 的操作，都會自動完成身分驗證，無須輸入帳號密碼。\n若有另外一台電腦，也是再產生一組 SSH Key 加入 Github 即可，而且我想，或許兩台電腦使用相同的 private key 也是可以的，這樣只需要一組 SSH Key 了。\n注意，不管是用在 SSH Key 或者 Deploy Key 都不可以重複，否則加入 Key 時會出現: Key is already in use 的錯誤訊息。\nStep1: 產生 key 的指令 ssh-keygen 參數 說明 範例 -t \u0026lt;key_type\u0026gt; 指定 金鑰類型，ed25519 是一種較新的橢圓曲線演算法，比 rsa(預設)更安全、更快，且金鑰較短。 -t ed25519 -C \u0026lt;comment\u0026gt; 設定金鑰的 註解 (comment)，通常用來標記用途，例如 GitHub 會建議填入 Email 來區分不同設備的金鑰。 -C \u0026quot;your_email@example.com\u0026quot; -b \u0026lt;bits\u0026gt; 金鑰長度（只適用於 rsa，ed25519 沒有這個選項） -b 4096（預設 3072） -f \u0026lt;file\u0026gt; 指定金鑰存放位置（預設存於 ~/.ssh/id_ed25519） -f ~/.ssh/my_github_key -N \u0026lt;passphrase\u0026gt; 設定金鑰密碼（空字串 \u0026quot;\u0026quot; 代表無密碼） -N \u0026quot;mypassword\u0026quot; -y 從私鑰產生對應的公鑰 ssh-keygen -y -f ~/.ssh/id_rsa \u0026gt; ~/.ssh/id_rsa.pub -q 安靜模式（不顯示輸出） -q 範例，於終端機則一輸入:\nssh-keygen，沒給參數則會引導一步步輸入 ssh-keygen -t ed25519 -C \u0026quot;my_email@example.com\u0026quot;，指定用 ed25519 算法產生晶鑰，並加入 comment 訊息。 輸入後就會產生一對 Keys，帶有尾墜.pub 的是 public_key，沒有尾墜的是 private_key。\nStep2: 將 public_key 加入 Github: 於終端機用 cat id_rsa.pub 讀出 public_key，並複製輸出結果。 到 Github 點擊頭像 -\u0026gt; Settings -\u0026gt; 左邊欄位選擇 SSH and GPG Keys -\u0026gt; 選擇 New SSH Key -\u0026gt; 貼上 public_key。 Step3: 測試 SSH 連線指令 ssh -T git@github.com: 可用來測試連線，-T 代表禁用虛擬終端分配，因為 GitHub SSH 伺服器不提供 shell 存取，使用 -T 不會開啟遠端終端機，只是測試身份驗證是否成功。\n如果驗證身分成功，你會看到 Hi WSMao! You've successfully authenticated, but GitHub does not provide shell access.\n補充:若你使用 deploy key 存取 github.com 時，則會提到特定 repository 名稱 Hi WSMao/hugo_blog! You've successfully authenticated, but GitHub does not provide shell access.\nStep4: 嘗試使用 git 指令 看 git clone git@github.com:WSMao/hugo_blog.git 是否 clone 成功就知道 SSH Key 設定是否生效。若出現失敗訊息 Please make sure you have the correct access rights and the repository exists. 可能就是 SSH Key 沒有設定好。\n其他討論 為何一直說 HTTPS 密碼驗證已經被 deprecated 但 Github 卻還提供 Clone using the web URL 的 HTTPS 選項? GitHub 禁止的是 Git 操作時使用密碼驗證(此密碼就是登入 Github 之密碼)。在網頁登入 GitHub 時仍然是使用密碼，但透過 HTTPS 的 Git 操作不能再用密碼。\n儘管 GitHub 在 2021 年 停用了使用帳號密碼的方式進行 Git 操作，但是仍然可以使用 HTTPS + Personal Access Token（PAT）來驗證並進行 git clone 等操作。 如果你使用 HTTPS 並看到提示要求輸入密碼，那麼密碼應該是 Personal Access Token，而非 GitHub 帳號密碼。\nPersonal Access Token (PAT) 是 GitHub 提供的一種更安全、更靈活的身份驗證方式，可以用來替代密碼，並可設置具體權限和範圍。\n是一串由 GitHub 自動生成的長字元串，比普通密碼更長、更難猜測，通常包含字母和數字的組合。 專門為 API 認證 或 Git 操作（如 git clone, git push 等）而設計的令牌，當你使用 HTTPS clone 或 push 操作時，會被要求提供 Personal Access Token 作為密碼。 使用 範圍（scope）來控制權限，意味著它可以限制你執行的操作範圍，並且可以隨時撤銷或更換。例如，你可以創建一個只有 repo 權限的 PAT，這樣它只能存取你的私人儲存庫，而不能進行組織管理或其他更高層級的操作。 為何 SSH 比 HTTPS 更適合 Git 操作? HTTPS 不也是使用了公私鑰? SSH 和 HTTPS 都有公私鑰加密，但它們的重點不同，SSH 更強調 身份驗證 和 加密通信，而 HTTPS 則專注於 加密資料傳輸 和 伺服器身份認證。\n主要差別是:\nSSH 強調的是對 client 端的身分驗證，所以 client 端要自己製作 SSH Key，上傳 public_key 並在本地端保管 private_key。 HTTPS 則相反，強調的是對 server 端的身分驗證，使用 憑證機構（CA）簽署的 SSL/TLS 證書來驗證伺服器的真實性，client 端藉此確認 server 有通過驗證。 對於 Github 應用來說，主要是要進行 client 端的身分驗證，這正是 SSH 本就擅長的部份。HTTPS 雖然也保障資料傳輸是安全加密的，但進行 client 身分認證的部分，還是得透過使用者輸入帳號密碼，即使現在改用 PAT 認證，還是沒有永遠不用輸入密碼的 SSH Key 機制來的安全。\n如何針對不同的 repo 指定不同的 SSH Key？ 你可以透過 ~/.ssh/config 設定不同 repo 使用不同的 Key。\n注意: 這裡主要是要探討若需要管理多把 keys 時， config 檔案可以如何設定。日常 Github 使用上，不太會有這個需求，因為只需要設定好 1 組 SSH key 即可。\n(1) 產生多組 SSH Key\nssh-keygen -t ed25519 -C \u0026#34;your-email@example.com\u0026#34; -f ~/.ssh/github_repo1 ssh-keygen -t ed25519 -C \u0026#34;your-email@example.com\u0026#34; -f ~/.ssh/github_repo2 這會產生：\n~/.ssh/github_repo1（私鑰） ~/.ssh/github_repo1.pub（公鑰） ~/.ssh/github_repo2（私鑰） ~/.ssh/github_repo2.pub（公鑰） (2) 分別把 .pub 上傳到 GitHub\n進入 GitHub → Settings → SSH and GPG keys 分別把 github_repo1.pub 和 github_repo2.pub 加到 SSH Keys (3) 設定 ~/.ssh/config\nHost github-repo1 HostName github.com User git IdentityFile ~/.ssh/github_repo1 Host github-repo2 HostName github.com User git IdentityFile ~/.ssh/github_repo2 這樣，你可以用 github-repo1 或 github-repo2 來指定不同的 SSH Key。\n(4) 使用 git clone\ngit clone git@github-repo1:WSMao/repo1.git git clone git@github-repo2:WSMao/repo2.git 這樣就可以讓不同的 repo 使用不同的 SSH Key。\n","permalink":"https://wsmao.github.io/post/github-authentication/","tags":["Git","GitHub"],"title":"GitHub 的登入驗證機制"},{"categories":null,"contents":"基本指令索引 指令 說明 git add \u0026lt;file\u0026gt; 打包檔案變更 git branch 顯示本地分支列表 git commit -m \u0026quot;message\u0026quot; 提交改變，製作 commmit git checkout \u0026lt;commit-SHA\u0026gt; 提取某個 commit 版本 worktree git checkout -b \u0026lt;branch\u0026gt; 新增 branch git clone \u0026lt;url\u0026gt; 複製 remote repo 至 local git config 進行.git 工具設定 git diff \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; 比較版本差異 git fetch 取得遠端最新變更但不合併 git fetch --prune 清除已刪除的遠端分支 git init git 環境初始化 git ls-files 列出所有追蹤中的檔案 git log 查看 commit log, file log git merge \u0026lt;commit-SHA\u0026gt; 將指定 commit 合併至 HEAD git push 推送變更到遠端分支 git pull 拉取遠端分支並合併 git remote 查看 remote 設定 git reset 讓分支回到某個 commit git rebase \u0026lt;commit-SHA\u0026gt; 重新整理當前分支並套用變更 git reflog 查看 HEAD 的變更歷史 git restore 恢復 stage area 或者 worktree 的變更 git rm --cached \u0026lt;file\u0026gt; 讓 Git 保留檔案但停止追蹤 git status 查看目前 Git 的狀態 git show \u0026lt;commit\u0026gt; 可以看基本資訊，以及檔案差異 git stash 暫存當前變更 git tag \u0026lt;tag_name\u0026gt; 在當前 commit 打 tag 標籤 進階指令索引 指令 說明 git revert HEAD 新增反向 commit，用於取消最新的 commit，但保留取消歷史 git cat-file -p \u0026lt;commit-SHA\u0026gt; 還原 Git 物件的內容 git cat-file -t \u0026lt;commit-SHA\u0026gt; 查看物件類型 git ls-files -s 列出當前目錄下包含子目錄底下的 blobs git clone --recurse-submodules \u0026lt;URL\u0026gt; 一併下載相依的 submodules git cherry-pick 可以從 commit tree 的任何地方拿一個 commit 來放在 HEAD 上（只要那個 commit 不是 HEAD 的 parent） git rebase -i \u0026lt;commit-SHA\u0026gt; 互動式 rebase，若 rebase 之中有許多 commits 要剪下貼上，可以選擇只 rebase 那些 commits，甚至可以排序 觀念 Git 四大物件 快速定位 基本名詞及概念 主題 基本設定 連接 remote 狀態 檔案變動狀態\nM: Modify A: Add to staging area D: Deleted U: Untracted files in worktree. 檔案追蹤 git ls-files 列出所有追蹤中的檔案。 git rm --cached \u0026lt;file\u0026gt; 讓 Git 停止追蹤檔案。 .gitignore 用來設定 Git 忽略檔案的規則，其中列出的檔案 Git 會予以忽略，不會追蹤其改變。 但已經在追蹤的檔案，不受 .gitignore 檔案影響，必須先停止追蹤 (git rm --cached \u0026lt;file\u0026gt;)，再加入 .gitignore，之後該檔案的變動才不會被追蹤。 打包變更與提交紀錄 打包 指令 說明 git add . 打包所有檔案變更。 git add filename 打包指定檔案變更。 git add -p filename 選擇性地新增某檔案的部分變更。 所謂打包就是將 worktree 變更(Changes)儲存至 staging area(Staged Changes)。用意是將需要提交的變更先整理起來，再發一個 commit 提交出去。 比如你可能會想要將較不相關的變動分次提交，所以你會先打包相關的一部分儲存至 staging area，進行 commit 提交時，只有 staging area 的變更會被提交出去。沒有被 staged 的部分還維持在 \u0026ldquo;Changes\u0026quot;的狀態。\n提交 指令 說明 git commit -m \u0026quot;message\u0026quot; 提交改變，製作 commit git commit --amend -m \u0026quot;message\u0026quot; 拆掉最新的 commit 連同新提交到 staging area 的部分，重新製作 commit 取消更動 指令 說明 git restore -W . 就會恢復 Worktree 所有修改(預設選項) git restore -S . 就會恢復 Stage area 所有修改 (staged changes —\u0026gt; changes) 切換版本 指令 說明 git checkout \u0026lt;commit-SHA\u0026gt; 切換至指定 commit 版本 git checkout \u0026lt;commit\u0026gt; \u0026lt;file\u0026gt; 指定檔案回復到某個 commit 版本 git checkout . 切換至當前版本，相當於還原當前工作區所有修改，建議以 git restore . 指令取代 checkout 切換至某個版本、提取某個版本資料，均會更新工作目錄。\n整個 worktree 切換至指定 commit 版本\ngit checkout \u0026lt;commit-SHA\u0026gt; 必須是工作目錄目前沒有任何修改的檔案，否則給予警告不給切換，因為他要切換至其他版本了，將改變工作目錄，而目前的修改尚未保存。 切換後 HEAD 會指向該 commit。 指切換單一檔案至特定 commit 之版本\ngit checkout \u0026lt;commit\u0026gt; \u0026lt;file\u0026gt; 回復指定檔案到某個 commit 版本。只會更新 worktree 檔案內容，並不會動到 HEAD。 分支 在本地 repo 的 branch 稱為 local branch; 在 remote repo 的 branch 稱為 remote branch; 而在本地 repo 用來追蹤 remote branch 的稱作 remote-tracking branch。\n指令 說明 git branch 顯示本地分支列表。 git branch -a 顯示所有分支(包含遠端) git branch -vv 顯示所有分支的詳細訊息，包含 upstream 對應 git branch -d \u0026lt;branch_name\u0026gt; 刪除本地分支 git branch -rd \u0026lt;remote\u0026gt;/\u0026lt;branch_name\u0026gt; 刪除追蹤分支 (-r 代表 remote) git branch \u0026lt;branch_name\u0026gt; 新增 branch 於目前 HEAD 上 git branch \u0026lt;branch_name\u0026gt; \u0026lt;commit-SHA\u0026gt; 新增 branch 於指定 commit 上 git branch -f \u0026lt;branch_name\u0026gt; \u0026lt;commit-SHA\u0026gt; 強制將現有 branch 改貼到指定 commit 上，但不可以是 HEAD 正指向之 branch git checkout -b \u0026lt;branch_name\u0026gt; 新增 branch 於目前 HEAD 上並切換到該分支 git checkout \u0026lt;commit-SHA\u0026gt; -b \u0026lt;branch_name\u0026gt; 新增 branch 於指定 commit 上並切換到該分支 其他相關:\ngit fetch --prune 若遠端已沒有該分支但本地端還有其追蹤分支的話，予以刪除。 標籤 指令 說明 git tag \u0026lt;tag_name\u0026gt; 新增 tag git tag \u0026lt;tag_name\u0026gt; \u0026lt;commit\u0026gt; 新增 tag 於指定 commit 上 git tag -d \u0026lt;tag_name\u0026gt; 刪除 tag git tag \u0026lt;tag_name\u0026gt; -a -m \u0026quot;message\u0026quot; 新增帶有註解（annotated）的 tag 查看歷史 指令 說明 git log 查看 commit 記錄 (預設為 HEAD 指向) git log --oneline 單行簡潔查看 commit 記錄 git log -- \u0026lt;path/to/file\u0026gt; 只查看某個檔案的 commit 記錄 git log -p -p 顯示變更內容 git reflog 查看 HEAD 的變更歷史 改變歷史 指令 說明 git reset \u0026lt;commit-SHA\u0026gt; 拆掉當前 commit，分支回到指定 commit(預設為 \u0026ndash;mixed) git reset --soft \u0026lt;commit-SHA\u0026gt; 拆掉當前 commit，分支回到指定 commit，拆除之變更保留在 staged 狀態 git reset --mixed \u0026lt;commit-SHA\u0026gt; 拆掉當前 commit，分支回到指定 commit，拆除之變更保留在 changes 狀態 git reset --hard \u0026lt;commit-SHA\u0026gt; 拆掉當前 commit，分支回到指定 commit，刪除所有變更 想像 commit1 到 commit2 的過程: commit1 -\u0026gt; changes -\u0026gt; staged changes -\u0026gt; commit2\n\u0026ndash;soft 就是回退 1 步到 staged changes 狀態 \u0026ndash;mixed 就是回退 2 步到 changes 狀態 \u0026ndash;hard 就是回退 3 步到 commit1 狀態 遠端協作 指令 說明 git fetch \u0026lt;remote\u0026gt; 取得遠端最新變更但不合併 git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 拉取遠端分支並合併到 HEAD git pull --rebase 表示要使用 rebase 的方式合併 fetch 下來的 commit git push 推送當前分支到對應的 upstream 分支 git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 推送指定分支同步至遠端 git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; --force 強制推送 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 推送時一併設定 branch upstream git branch -vv 可以使用此指令 查看 branch 是否設置 upstream git remote 查看 remote repo git remote -v -v for verbos 提供更多訊息 git remote add \u0026lt;remote\u0026gt; \u0026lt;remote repository URL\u0026gt; 建立 remote repository 指標 upstream upstream 就是 \u0026lt;local_branch\u0026gt; 預設進行 push/pull/fetch 等指令的 \u0026lt;remote_branch\u0026gt; 分支。 設定好 upstream 使得進行 push/pull/fetch 等指令時，不用每次都詳細指定 \u0026lt;local_branch\u0026gt; 是要跟哪個 \u0026lt;remote_branch\u0026gt; 互動，會比較方便。 若設定 \u0026lt;remote_branch\u0026gt; 為 \u0026lt;local_branch\u0026gt; 之 upstream，當然也可以反過來說 \u0026lt;local_branch\u0026gt; 是 \u0026lt;remote_branch\u0026gt; 之 downstream。\n建立 upstream 當 remote 端已有該 branch 時，我們可以這樣建立 upstream。\n必須要先取得該 \u0026lt;remote_branch\u0026gt; 的追蹤分支，使用 git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;。 為當前 HEAD 指向的 branch 設定 upstream，使用 git branch -u \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; 或 git branch --set-upstream-to=\u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt;。 也可以指定為哪個 branch 設定 upstream，git branch -u \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; \u0026lt;branch\u0026gt; 或者建立參考於 \u0026lt;remote_branch\u0026gt; 的新分支 git checkout \u0026lt;remote\u0026gt;/\u0026lt;branch\u0026gt; -b \u0026lt;branch\u0026gt;，就會自動設立 upstream 關係。 而若是遠端沒有該 branch，我們可以推送 \u0026lt;local_branch\u0026gt; 上去建立 \u0026lt;remote_branch\u0026gt; 同時建立 upstream 關係。 git push -u \u0026lt;remote\u0026gt; \u0026lt;local_branch\u0026gt;:\u0026lt;remote_branch\u0026gt; 或者 local 跟 remote 同名的話 git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;。\n取消 upstream git branch --unset-upstream\n查看 upstream git branch -vv 可以看到所有 branch 的詳細訊息，包含該 branch 是否有 upstream branch。 git remote show \u0026lt;remote\u0026gt; 會顯示 \u0026lt;remote\u0026gt; 的詳細訊息，包含 \u0026lt;local_branch\u0026gt; 對應到的 \u0026lt;remote_branch\u0026gt;，即 upstream。 git clone 若是由 github clone 下來的 repo，預設只會得到 1 個 default branch 以及 1 個 指向該 github repo 的 remote(名為 origin)。 使用 git branch -a 可以看到其他 remote 分支，若你想要建立該 \u0026lt;remote_branch\u0026gt; 的 downstream 可以 git branch \u0026lt;branch\u0026gt; \u0026lt;remote_branch\u0026gt;。 git push 一定要知道來源與目標，來源可以是 commit 但目標一定是 branch，目標不存在也沒關係，會自動創建。 push 前，須保證不會 conflict，所以會被檢查 remote_branch 的 history，local commit 是否都有，若沒有要先 fetch 更新，merge 後在 local 解決衝突才能重新 push。\ngit push \u0026lt;remote\u0026gt; \u0026lt;commit\u0026gt;:\u0026lt;remote_branch\u0026gt; 即 push \u0026lt;local_branch\u0026gt; -\u0026gt; \u0026lt;remote_branch\u0026gt;，意思是把 \u0026lt;local_branch\u0026gt; 上傳到 \u0026lt;remote\u0026gt; 然後合併到 \u0026lt;remote_branch\u0026gt;，如果 remote repo 沒有該 branch 則會在 remote 上自動創建一個。 可以看到本地跟遠端的分支名稱可以不同，雖然很少會需要這麼做。 甚至本地端可以直接指定 commit git push \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt;\n同名，把同名 local 同步到 remote git push\n都沒給參數代表可以推理出來，當前 HEAD 需指向設定好 upstream 的 branch，如此可推得 \u0026lt;remote\u0026gt; 以及 \u0026lt;remote_branch\u0026gt;。 特別技: 如何在 local 端刪除 remote 端的分支? 就是讓 \u0026lt;local_branch\u0026gt; 的地方留空，git push \u0026lt;remote\u0026gt; :\u0026lt;remote_branch\u0026gt; ，push 一個空 branch 到 remote 代表刪除。\ngit fetch 主要是更新遠端分支的狀態(所以 tracking-branch 會改變)，若有需要會自動創建 remote-tracking branch。\ngit fetch\n更新所有 remote_branch 的狀態。 git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 更新指定 remote_branch 的狀態。 git fetch \u0026lt;remote\u0026gt; \u0026lt;src\u0026gt;:\u0026lt;dst\u0026gt; 我個人認為不要使用，因為他讓 fetch 不再只是單純更新 tracking-branches 的動作，還包含快速移動分支等 merge 概念，概念被複雜化了。 可指定更新給誰，可以是 local branch 或 tracking branch 或 HEAD dst 不可是當前 checkout 的分支 若 src 是 branch 則會更新 tracking branch 也會將新的 commit 增加到 dst 上。 若 src 是 commit 則不會更新 tracking branch，只會將新的 commit 增加到 dst 上。 git pull git pull = git fetch + git merge，也就是 fetch 遠端分支的更新，並嘗試 merge。\n記得 merge 是針對 HEAD 位置的操作。\ngit pull \u0026lt;remote\u0026gt; \u0026lt;remote_commit\u0026gt;:\u0026lt;local_branch\u0026gt; = git fetch \u0026lt;remote\u0026gt; \u0026lt;remote_commit\u0026gt;:\u0026lt;local_branch\u0026gt; + git merge \u0026lt;local_branch\u0026gt;\n我個人認為不要使用，因為指令結果複雜不好記憶，fetch 指令在這樣的格式下不只是 fetch remote 狀態，還會移動 local_branch，然而 pull 又包含 merge 又會移動 HEAD 位置。總之若非很熟悉，太複雜的指令沒必要用，可以用多個基礎指令一步步完成就好，好記又不容易錯。 得以指定 fetch source 以及 merge target 由 HEAD 指向的 branch 去 merge 收到 fetch 的 \u0026lt;local_branch\u0026gt; git pull origin bar:bugFix 相當於：\ngit fetch origin bar:bugFix; git merge bugFix git pull \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; = git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; + git merge \u0026lt;branch\u0026gt;\ngit pull origin foo 相當於：\ngit fetch origin foo; git merge origin/foo git pull = git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; + git merge \u0026lt;remote_branch\u0026gt;\ngit pull 沒有參數，故由 HEAD 指向之 branch 推論，該 branch 需要設定好 upstream，固可推得哪個 \u0026lt;remote\u0026gt; 以及哪個 \u0026lt;remote_branch\u0026gt;。 可以看到使用 git fetch \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; 只會取得 upstream 更新，並不是 git fetch 取得所有更新。 git pull 相當於:\ngit fetch \u0026lt;remote\u0026gt; \u0026lt;upstream\u0026gt; git merge \u0026lt;upstream\u0026gt; 合併 Merge 指令 說明 git merge \u0026lt;commit-SHA\u0026gt; 當前分支嘗試合併某 commit 內容 (fast forward 優先) git merge \u0026lt;commit-SHA\u0026gt; --no-ff -m \u0026ldquo;merge message\u0026rdquo; 使用 \u0026ndash;no-ff 禁用 fast forward，必會產生 merge 訊息 git merge --squash \u0026lt;commit-SHA\u0026gt; ??? git merge --abort 當 merge conflict 時，若想放棄這次 merge 回復 merge 前狀態時使用 git merge 一定是對 HEAD 位置 merge，HEAD 不一定要指向 branch(但通常是)，merge 完 HEAD 會移動，若HEAD 指向 branch 則 branch 也會移動。\nFast Forward（快速前進）是一種 合併（merge）策略，當 當前分支的 HEAD 沒有與目標分支產生分歧，而目標分支只是在 HEAD 之後新增了 commit 時，Git 會直接把 HEAD 指向最新的 commit，而不產生新的 merge commit。\nFast Forward 合併的條件：只要 commits 鍊是可以溯源，那必定可以 Fast Forward。 比如當前分支 A 是目標分支 B 的祖先之一，那從 B commits 溯源並訂可以找到 A commits，則必可以 Fast Forward。\nNo Fast-Forward 的 merge，必定會額外產生出一個 commit 紀錄是由哪兩個 commit 合併的，故會看到 2 個 parents。當你想要特意保留 merge 訊息可使用。 Fast-Forward merge 則不會有 merge commit，僅是將當前分支直接快轉移動貼到另一個 commit 上，故會看不出來曾經有與其他 branch 合併過。 Merge Conflict 當兩分枝執行合併，但兩個分支都修改了一樣的內容，導致讓 git 不知怎麼合併，這就是 merge conflict。 此時，merge 會被暫停並且 git 會把衝突的檔案以及兩分枝的差異標示給你看，讓你自行選擇怎麼修正。 不管你怎麼修正，修完之後再次 git add、git commit 提交，就算是解決 conflict 了。\nRebase 指令 說明 git rebase \u0026lt;commit-SHA\u0026gt; 把自己跟別人不同的 commit 都剪下重新長在別人身上。 git rebase --continue 當 rebase 遇到 conflict 時，待解決後以此指令繼續 rebase 過程。 git rebase \u0026lt;on-commit\u0026gt; \u0026lt;from-commit\u0026gt; 比對 commits 差異，將 不同的 commits 剪下貼在 上 git rebase -i \u0026lt;commit-SHA\u0026gt; 互動式 rebase，自由決定要剪下哪些 commits，還可以調整順序，按照指定順序重新長在指定之 commit 上! git pull --rebase 使用 rebase 的方式處理 fetch 到的 commit Rebase 與 merge 之差別:\n不會另外做出 merge 物件。 有點像將 commit 剪下貼上的概念，把新增的 commits 都剪下，基於 base 重新製作 coomits。 比如說有兩個 branches branch_A，branch_B 共同的 parent 是基於 commit_parent，此時若要用 rebase 方式合併，假設說要 let branch_A rebased on branch_B，則會發現她會把從 commit_parent 之後 branch_A 長出的 commit 一個個剪下，且重新插枝在 branch_B 現在的 commit 上。假設從 commit_parent 之後 branch_A 長出 2 個 commits，那就會將這兩個 commits 剪下，然後 rebased on branch_B，重新製作兩個 commits 插到 branch_B 之後。所以這時候，會看到 branch_A 與 branch_B 在同一條路上了，而且 branch_A 領先 branch_B 2 個 commits。\nrebase 完會 branch 會前進，移動到新 commit 上。\n注意: rebase 是修改 commit 歷史的行為。\nCherry-Pick git cherry-pick \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; \u0026lt;commit3\u0026gt;... 就是去複製某些 commit 重新製作嘗試將改變貼自己身上(HEAD)。\n這是一個非常強大的工具，甚至讓你可以重新整理你的整個 branches 之 commits 排列順序等等。\ncherry-pick 沒有改變歷史，他是造新的一條 branch 出來。cherry-pick 也會讓 HEAD 以及 branch 移動。\n暫存變更 指令 說明 git stash 暫存當前變更 git stash -m \u0026quot;\u0026lt;message\u0026gt;\u0026quot; -m 可以註解提供說明訊息 git stash list 列出所有 stash git stash pop 取回最近一次的 stash，並從列表中移除 git stash pop \u0026quot;stash@{\u0026lt;num\u0026gt;\u0026quot;} 取回編號 num 的 stash，並從列表中移除 git stash apply 取回最近一次的 stash，但不從列表中移除 git stash drop 刪除最近一次的 stash git stash clear 清除所有 stash pop/apply/drop 都可以按照 stash id 選擇存取哪個 stash。 stash id 編號越小越近期的 stash 不論是 worktree 變更或者已經 staged 的變更，都可以被 stash。只不過 pop 回來都會變成是 changes 狀態，不會是 staged 的狀態。 即使 stash 是在比較舊的 commit 上，而 pop 時 HEAD 是在比較新的 commit 上，只要不衝突，依然可以成功 pop 將變更加入。 差異比較 指令 說明 git diff 比較 a.暫存區 與 b.工作區 git diff HEAD 比較 a.當前 commit 與 b.工作區 git diff --staged 比較 a.當前 commit 與 b.暫存區 git diff \u0026lt;commit\u0026gt; 比較 a.某個 commit 與 b.當前 commit git diff \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt; 比較 a.commit1 與 b.commmit2 git diff \u0026lt;commit1\u0026gt;..\u0026lt;commit2\u0026gt; -- \u0026lt;file\u0026gt; 比較 a.commit1 與 b.commmit2 間指定檔案之變化 基本名詞及概念 HEAD HEAD 是一個 reference，他可以指向 branch 也可以直接指向 commit，不管是哪種，它最終都可以推論出一個 commit，表示目前所 checkout 的 commit。\nHEAD -\u0026gt; branch -\u0026gt; commit HEAD -\u0026gt; commit 輸入指令時因為 HEAD 往往已經指向某個 commit，許多針對當前 HEAD 指向之指令就可以不用再指定 commit，非常方便。 cat .git/HEAD 可以查詢 HEAD 指向 當 HEAD 不是指向 branch 則稱為斷頭(detached head)。\ngit checkout \u0026lt;branch\u0026gt; 為 HEAD -\u0026gt; branch -\u0026gt; commit，沒有斷頭。 git checkout \u0026lt;commit\u0026gt; 為 HEAD -\u0026gt; commit，就會形成斷頭。 git checkout \u0026lt;tag\u0026gt; 為 HEAD -\u0026gt; commit，也會形成斷頭。 其他 branch 指向某個 commit，會隨著新的 commit 移動。 remote 是遠端 repository。 upstream 就是某個 branch 其預設 push 的 remote。 commit 指向 root tree object 以及 parent commit。 快速定位 依照 HEAD 移動紀錄\n由 git reflog 可看到 HEAD 的移動紀錄 ＠ 可代表 HEAD git checkout \u0026quot;@{1}\u0026quot; 定位 HEAD 的上 1 動之 commit 位址 git checkout \u0026quot;@{4}\u0026quot; 定位 HEAD 的前 4 動之 commit 位址 依照 commit 指向的第一個父 commit 去回溯。\n^ 代表「parent（父節點）」，它會指向當前 commit 的 第 1 個父 commit。 格式 \u0026ldquo;^\u0026rdquo; git checkout \u0026quot;HEAD^\u0026quot; 或者 git checkout \u0026quot;@^\u0026quot; git checkout \u0026quot;HEAD^^\u0026quot; 則是往前回溯 2 次。 若 ^ 後面有數字比如 ^2 則代表指向當前 commit 的第 2 個父 commit。 ~n 代表「向前 n 代的 commit」，相當於不斷往 第一個父 commit 回溯 n 次。 格式 \u0026ldquo;~n\u0026rdquo; git checkout \u0026quot;HEAD~1\u0026quot; 或者 git checkout \u0026quot;@~1\u0026quot; 或者 git checkout \u0026quot;3bdf7c55~1\u0026quot; 或者 git checkout \u0026quot;main~1\u0026quot; 有趣的是移動是可以疊加的，可以 @^^~^^ @^^2^^~~ main^2~3 Git 四大物件 Git 有：blob / tree / commit / tag 四大物件。\n每個 git 物件之檔名，均是由內容(不確定是壓縮前或後)及一些其他資訊所計算出的 SHA 值，即使內容只有一個字元差異，也會產生一個新的 git 物件。SHA 的算法很好的用作 ID 表示特定的檔案，且每個檔案名稱長度相同，方便物件關聯檔案控管。\n而這些物件的檔案內容則都是壓縮過的，可以用工具還原為未經壓縮之內容。\n物件檢視\ngit cat-file -t \u0026lt;commit-SHA\u0026gt; 查看物件類型。 git cat-file -p \u0026lt;commit-SHA\u0026gt; 還原 Git 物件壓縮前的內容。 SHA 值計算 cat \u0026lt;file\u0026gt; | git hash-object --stdin 計算 git 物件之檔案名稱(SHA 值)。\nBlob 內容是原始檔案內容經過 git 壓縮演算法而成。 Tree 內容指向其他 Tree 或 Blob 物件(含 blob 原始檔案之檔名)。 Commit 內容指向 git 跟目錄的 Tree 物件 parent commit commit 訊息 \u0026hellip; Tag 指向一個 commit git add 後產生新的 Blob 物件。 git commit 後產生 Tree、commit 物件，把所有物件串起來。\n基本設定 設定\ngit config --global user.email \u0026lt;email_addr\u0026gt; git config --global user.name \u0026lt;username\u0026gt; 查看設定 git config --global --get user.name\n初次連接 remote repo 設定 remote 以及 upstream\ngit remote add \u0026lt;remote\u0026gt; \u0026lt;remote repository URL\u0026gt; git push -u \u0026lt;remote\u0026gt; \u0026lt;branch\u0026gt; ","permalink":"https://wsmao.github.io/post/git-cheatsheet/","tags":["Git","GitHub"],"title":"Git Cheatsheet."},{"categories":null,"contents":"當你的內心改變了，你感受到了生活的重量與責任，那一瞬間，你就悄悄長大了。\n或許是現實壓力撲向你的一瞬間，或許是與家人某次激烈的對談，也或許是分手的那一刻，那一刻你似乎頓悟了些什麼，因此你決心改變，決定不要再小孩子氣，要做個大人。\n","permalink":"https://wsmao.github.io/quote/%E9%95%B7%E5%A4%A7%E7%9A%84%E4%B8%80%E7%9E%AC%E9%96%93/","tags":["quote"],"title":"人是什麼時候長大的呢?"},{"categories":null,"contents":" SoC 是什麼? SoC 與 CPU 的差異與比較 控制硬體裝置的方式就是讀寫其暫存器 x86 的 I/O space。 NB 與 SB 晶片組 PCI Bus 實現 Pin 腳多工的 Crossbar 問題思考: Q1: 為什麼有些系統使用 PCI-to-PCIe 橋接，將 PCIe 掛載在 PCI 下？ 這樣速度較快的 PCIe 不就受限於較慢的 PCI? SoC 是什麼? SoC (System on Chip) 是一種將整個計算系統整合在單一芯片上的架構，包含多種功能模組。 它是嵌入式系統設計中非常普遍的選擇，因為小小的晶片就幾乎完備了運算系統需要的功能，可謂麻雀雖小五臟俱全。\n典型 SoC 包括以下模組：\nCPU： 處理核心，負責執行程式邏輯。 內存控制器： 直接管理與 DRAM 的連接。 存儲單元： 內建 SRAM 或快閃記憶體，用於存放程式和資料。 I/O 接口： 如 USB、UART、SPI、I²C 等。 GPU： 圖形處理器，用於圖形渲染或計算。 網絡模組： 支援 WiFi、Ethernet 或 5G。 應用場景包含手機、IoT 裝置、機器人、汽車電子、智慧家居設備等，高通 Snapdragon、Apple A 系列、NVIDIA Tegra 等都是 SoC。\nSoC 與 CPU 的差異與比較 CPU 是負責執行程式指令並處理數據的核心計算模組，它是任何計算機系統的主要運算單元。 典型 CPU 包括控制單元 (Control Unit)、算術邏輯單元(ALU)、暫存器(Registers)、快取記憶體 (Cache)。\n在嵌入式系統中，CPU 作為 SoC 的一部分，強調一體化，將多個功能模組整合在單一芯片。\n優勢為:低功耗、低成本、尺寸小、方便。 缺點為:由於設計是固定的，升級特定模組的能力有限，靈活性較低、多模組運作可能導致熱量集中的問題。 在個人電腦、伺服器應用，CPU 常是獨立組件，只負責運算，其他功能尚須要其他需要外部模組(如 GPU、I/O 控制器)來組成完整系統，強調性能。\n優勢為: 性能強、散熱強、擴充性強，因可任意組建並擴充系統。 缺點為: 體積大、耗能。 總結是 CPU 是通用的運算核心，可以搭配其他關鍵核心組成像是 PC、伺服器等需要高性能的應用系統。而 CPU 也可以被集成在 SoC 這樣高度整合的系統內，用於功耗敏感、體積有限的設備。\n控制硬體裝置的方式就是讀寫其暫存器 硬體裝置的操作主要是通過讀取或寫入裝置的暫存器來實現，這些暫存器為軟體提供了一個與硬體互動的介面。\n在 x86 架構中，裝置的暫存器可以被映射到 I/O space(Port-IO) 或 Memory Space(Memory-Mapped I/O, MMIO)：\n被映射到 I/O Space 下的暫存器需使用特殊的指令（如 IN 和 OUT）來存取。 映射到 Memory Space 下的暫存器則可透過一般讀寫記憶體的指令存取。 映射通常由 BIOS 配置，BIOS 在系統啟動時負責初始化硬體，包括列舉和配置 PCI 裝置。對於 PCI 裝置，BIOS 通常會為每個裝置分配資源，比如 I/O Port 空間或 MMIO 空間，並將這些資訊寫入裝置的 PCI Configuration Space 中的相關欄位，例如 Base Address Register (BAR)。\nuser 需要去查詢裝置暫存器映射的 Base Address，知道地址就能操作裝置的暫存器進而控制裝置。\n補充: 在一些嵌入式系統（如 ARM 或 RISC-V 平台）中，裝置通常使用 Memory-Mapped I/O (MMIO)，不區分 I/O Space 和 Memory Space。 而如果系統使用的是較新的技術像是 UEFI，則可能由操作系統完成資源分配和配置。\nx86 的 I/O space。 這是 x86 架構下 I/O 暫存器的存取介面，透過將周邊裝置之暫存器映射到 I/O Space，就能夠透過讀寫 I/O Space 的方式來控制裝置了。\nx86 的 I/O Space 只有 64KB 大小的空間，而且其中許多位址都已保留給特定裝置使用(比如 PCI)。\nNB 與 SB 晶片組 北橋 (North Bridge) 的角色\n高速橋接：NB 是 CPU 與其他高速設備（例如記憶體和 PCI 線路）之間的中介橋。 負責連接 CPU 和高速裝置: 系統總線管理：負責管理 CPU 與 PCI 總線之間的資料流動。 記憶體控制器：負責 CPU 與 DRAM 的連接，處理高速資料傳輸。 圖形接口：連接高性能圖形裝置（如 AGP 或 PCIe 的圖形卡）。 南橋 (South Bridge)\n負責低速裝置的連接，如 ISA、串列埠、並列埠等。 通常提供 PCI 到 ISA 的橋接功能。 在傳統的嵌入式或桌上型電腦系統中，CPU 與 NB 是系統架構的核心組件，兩者的關係如下：\n高速連接： 透過前端匯流排（Front-Side Bus, FSB）相連。 FSB 提供 CPU 與 NB 間的高速資料傳輸通道。 共享控制： CPU 通過 NB 控制其他裝置，例如記憶體和外設。 在更現代的設計中，CPU 通常內建記憶體控制器，NB 的角色漸漸由 CPU 整合。此時，PCIe 和其他高速裝置直接與 CPU 連接，而不是經由 NB。\nPCI Bus 每個 PCI 裝置都有一個標準化的 PCI Configuration Space 用來存放其配置資訊，例如裝置 ID、Vendor ID、BAR (Base Address Register) 等。 裝置之 PCI Configuration Space 的地址由 [bus(8-bit), device(5-bit), function(3-bit)] 決定，再由 offset(8-bit) 決定 PCI 暫存器位址，故每個裝置之 PCI 暫存器空間大小只有 256 Bytes，雖然小但只存放系統配置資訊是夠用的，裝置非 PCI 的暫存器實際上會映射到 I/O Space 或 Memory Space 去。\nx86 架構中，在 I/O space 為 PCI 暫存器保留兩個固定位址，作為操作 PCI Configuration Space 的介面。\n0x0cf8 (4 Bytes) 為 PCI Register Address，由 [bus, device, function, offset] 構成。 0x0cfc (4 Bytes) 為 PCI Data，不管是讀取或寫入 PCI 暫存器都是經由這個 I/O space 位址。 讀取 PCI Register:\nuser 將目標 PCI Register 地址寫入 I/O space 0x0cf8。 user 對 I/O space 0x0cfc 進行讀取操作，PCI 就會將暫存器資料寫到 0x0cfc 內返回給 user。 寫入 PCI Register:\nuser 將目標 PCI Register 地址寫入 I/O space 0x0cf8。 user 對 I/O space 0x0cfc 進行寫入操作，PCI 就會將 0x0cfc 的資料存取到暫存器內。 BIOS 在啟動時會掃描所有的 PCI 裝置，為每個裝置分配其暫存器在 I/O Space 或 Memory Space 的映射基底地址，提供操作暫存器的介面。\n實現 Pin 腳多工的 Crossbar SoC 可謂多功能但體積小，物理上的限制使得其腳位數量不足以為所有 SoC 的功能都引出腳位來。 有了 Crossbar 這種切換器，使得腳位可以多工選擇要連接的功能為何，比如說透過設定 Crossbar，我可以選擇 SoC 引腳 Port 5, Pin 3，要使用 GPIO 功能，或者使用 UART Tx 功能。\n總之，有了 Crossbar，得以讓 SoC 用戶自己為腳為選擇需要的功能，這讓腳位少但功能豐富的 SoC 足以滿足各種需求。\n問題思考: Q1: 為什麼有些系統使用 PCI-to-PCIe 橋接，將 PCIe 掛載在 PCI 下？ 這樣速度較快的 PCIe 不就受限於較慢的 PCI? 確實，將 PCIe 裝置掛在 PCI-to-PCIe 橋接器下，會因為橋接器的設計而受到 PCI 總線速度的限制（如 PCI 的最大傳輸速度為 133 MB/s）。然而，這樣設計並非偶然，而是基於以下原因：\n向後兼容: 系統需要支援老舊的 PCI 總線設備，同時也想引入現代 PCIe 設備的功能。 某些嵌入式或工業系統需要延續支持舊裝置，但無法完全放棄 PCI 架構。PCI-to-PCIe 橋接提供一個過渡方案，使新型 PCIe 設備能在舊系統中運行。 嵌入式應用中使用 PCI-to-PCIe 來提供特定接口（如 USB、網路等），這樣的作法主要是功能導向而非性能導向，外接的 PCIe 裝置僅需低速數據傳輸。\n設計成本考量: 使用橋接器比重新設計整個系統更節省成本，如果直接用 PCIe 作為系統總線，將需要修改硬體架構、PCB 佈局，甚至需要開發新驅動。 而橋接器是一種低成本、高兼容性的即刻解決方案。\n應用案例\n嵌入式工業系統： 工業主板使用 PCI-to-PCIe 橋接，允許開發者將舊型 PCI 模組升級為 PCIe 模組，增加壽命。 過渡時期主板： 早期 PCIe 系統（如 2000 年代的桌機主板）同時包含 PCI 和 PCIe 插槽，使用 PCI-to-PCIe 橋接來支援 PCIe 顯卡或擴充裝置。 混合式嵌入式平台： 工廠中的控制系統同時需要舊有的 PCI 通訊模組和現代化的 PCIe 網路模組，橋接技術便於整合。 橋接器允許一個系統同時支持 PCI 和 PCIe 裝置，這在過渡時期的主板設計中非常常見。 將 PCIe 掛載在 PCI 下雖然限制了 PCIe 的性能，但這樣做的目的是為了兼容性、成本考量，這可能是設計者考量到功能需求多於性能需求，而選擇的一種實用解決方案。如果性能是主要需求，則可能需要考慮升級到完整的 PCIe 架構。\n","permalink":"https://wsmao.github.io/post/embedded-architecture/","tags":null,"title":"Embedded System Overview."},{"categories":null,"contents":"Hugo 內建的 Syntax Highlight - Chroma Hugo 提供了一個內建的語法高亮工具，基於 Chroma，它是一個用 Go 語言編寫的語法高亮庫。Hugo 可以自動處理程式碼塊的語法高亮，並且內建支援許多語言和樣式。\n是 Go 語言 Chroma 套件完成的 在你使用 hugo 將 markdown 轉成 html 時，就完成語法高量了，所以是在 server 端進行。 Highlight.js 是一個純 JavaScript 編寫的語法高亮庫，廣泛用於網頁中，支持大量程式語言和顏色樣式。\nhighlight.js 是 javascript 語法，當整個 html 頁面載入後，在 client 端完成渲染。 他會搜尋 pre code 元素，完成顏色渲染。 可參考這篇 - 使用 highlight.js 就可以載入成功。\nrefs:\nhighlight.js Fetch via CDN 比較總結 特徵 Hugo 內建語法高亮 Highlight.js 實現方式 服務端渲染（靜態生成 HTML） 瀏覽器端處理（JavaScript） 性能 較快，無需依賴外部資源 較慢，依賴外部 JavaScript 和 CSS 加載 語言支持 支援多種語言，但較為有限 支援超過 180 種語言，靈活可擴展 樣式選擇 多種內建樣式可選 提供豐富的樣式選擇，可根據需求選擇特定主題 SEO 友好性 高，因為高亮是服務端渲染的 低，因為高亮是瀏覽器端處理的，搜尋引擎無法讀取高亮結果 配置複雜度 配置簡單，無需引入外部資源 需要手動引入外部庫，並配置相關的 JavaScript 和 CSS 互動性 無 可以動態切換主題或語言，提供更多的互動性 結論 Hugo 內建語法高亮 適合於靜態網站，提供快速、簡單且高效的語法高亮，對 SEO 友好，且配置簡單。適合需要快速構建靜態網站，並且不需要太多動態效果的情境。 Highlight.js 更加靈活，適合需要高度自定義、動態處理程式碼高亮的網站。若需要豐富的語言支持或互動性，可以選擇這個庫，但需要注意性能和加載時間的影響。 Hugo 自帶 Syntax Highlight 工具，但我更傾向於使用 Highlight.js 來實現，因為\n許多網站使用，支援更多語言與更多主題樣式，其中我很喜歡他的 night-owl 這個樣式用在 C 語言的效果。 相比於 GO 語言，我更想使用 javascript，且目前 GO Chroma 直接產生出靜態檔案，將樣式都寫死在 element 中，不方便調整，更何況也找不到如何客製調整，換句話說，我無法進行任何 style 控制，只能選用為數不多的現成主題。 而 highlight.js 則是動態在 client 端渲染，由指定載入的 css 跟 js 檔案來控制，只要引入不同的樣式，就可以動態更改，若他眾多樣式我都不喜歡，我也可以去下載 css 並自行調整樣式設定，即可套用我自定義的樣式。 ","permalink":"https://wsmao.github.io/hugo/plugin-syntax_highlight/","tags":["HUGO"],"title":"Plugin - Syntax Highlight"},{"categories":null,"contents":" Introduction 幾種 Modbus 形式: Modbus-RTU、Modbus-ASCII、Modbus-TCP RS-485 簡介 Modbus-RTU 協議 Modbus Frame Function Code Modbus Slave Register Map Modbus RTU 之傳輸時間間隔 Example 實測 測試目的與方法 測試環境 結果 延伸討論 為何 Modbus 使用 RS-485 僅支持 32 個設備？ Modbus ASCII 和 Modbus RTU 比較 References Introduction Modbus 是常用的工業總線協議，屬於 Application Layer，工業上常用 Modbus-RTU 搭配 RS-485 或者 Modbus-TCP 搭配 Ethernet 來傳輸，也可以使用 UART 或 RS-232 甚至 RF 等無線媒介傳遞 Modbus 協議，並沒有規定一定要搭配哪種實體層。本文著重介紹 Modbus-RTU 搭配 RS-485 的通訊架構。\nModbus 幾種類型與傳輸媒介搭配:\n幾種 Modbus 形式: Modbus-RTU、Modbus-ASCII、Modbus-TCP Modus-ASCII 早期這個協議用比較多，但被傳輸更有效率的 Modbus-RTU 取代，請參考與 Modbus-RTU 之比較。\nModus-RTU Modbus-RTU (Remote Terminal Unit) 的命名強調了它的應用場景是為遠程設備之間的高效通訊而設計。\nModbus-RTU 協議規定採用 Master / Slave 架構，一律由 Master 發起通訊，相應的 Slave 進行回應。 因為 Modbus 為 Application 協議，並無規範用什麼媒介傳遞\n故可以選擇 UART TTL 直接傳輸，或者加上 MAX232 晶片，採用 RS-232 傳輸標準。這兩者都是 point-to-point 拓樸，即 1 個 Master 對 1 個 Slave 點到點傳輸。 不過工業界用最多的還是 UART 加上 MAX485 晶片的 RS-485 標準，比起 RS-232 有眾多優勢，並且他是 Bus topology，多裝置得以連接在同一 fieldbus 上，即 1 個 Master 對多個 Slaves，非常適合工業自動化多設備連接。 Modbus-TCP 核心封包結構 Modbus-RTU 沒有差很多，只是是經由 Ethernet 媒介的網路架構，這使使得 Modbus-TCP 在許多方面都比 Modbus-RTU 來的強大，不論是速度、裝置數量限制，拓樸等。\nEthernet 通過交換機可形成 Star topology，得益於 Ethernet 架構，可以設計為 Ethernet client / server 形式，能有多個 clients 端，亦能同時對多個 Slaves 發起請求。\nModbus-RTU 與 Modbus-TCP 重點比較 Modbus-RTU 模式\n採用 Master/Slave 架構，由 Master 發起 request 並等待 slave response，常見的實作是 blocking 的方式，若有多個裝置，那就是由 Master 一一去 polling 多個 Slaves 裝置。而實作成非阻塞(non-blocking)或非同步(asynchronous) 的 Modbus RTU 是完全可行的，並且在某些情況下更高效。 通信延遲取決於波特率、串行接口速度，以及訊息間的 3.5 字元時間間隔。且單次通信通常只能處理一個主從請求，當設備數量增加或通信頻繁時，效率下降明顯。 適用於短距離、低成本的串行通信環境。搭配 RS-485 可支援多節點通信，適合小型分布式系統。 Modbus-TCP 模式\nClient 可以一次對多個 Servers 發出 request，是較快速的資料交換方式，但 Servers 的 response 順序不一定照著 request 的順序，這是網路的特性。 因為採用 Ethernet，因此可以輕鬆與許多其他 Ethernet 裝置或者透過 Ethernet Gateway 與其他總線協議共享同一網路，擴充性更好。 Modbus-TCP 是將 Modbus-RTU 的 PDU（Protocol Data Unit）封裝為 TCP 的應用層數據; Slave ID 則改用 ip address; 且捨棄原本的 CRC 校驗欄位，採用 TCP/IP 協議的校驗機制。 基於高速以太網，通信延遲較低，可同時處理多個 TCP 連線，支援更高數量的設備，實現並行通信，不會因為單線阻塞而影響整體效率。 常用於現代化的工業控制系統，支持雲端和遠程監控，可直接集成於 IT 網絡，與其他基於 TCP/IP 的系統無縫通信。 設備需要以太網接口，硬體成本較高，且實現相對複雜，需要 TCP/IP 協議棧支持，需要配置 IP 地址、子網掩碼和網關等網絡參數。 特性 Modbus RTU Modbus TCP 傳輸媒介 RS-232 / RS-485 Ethernet 傳輸速率 低（受波特率限制，例如 9600bps、115200bps） 高（受網絡速率限制，可達數百 Mbps） 設備數量 受限（最多 32 個節點） 基於 ip，幾乎無限 通信效率 單線串行通信，效率低 多連接並行通信，效率高 設備成本 低 較高 配置難度 簡單 複雜 適用場景 小規模、低成本工業通信 大規模、現代化網絡通信 架構 需要明確的主從關係（Master/Slave） Client/Server 架構，可同時與多個設備通信 根據應用需求選擇：\n如果系統規模小，且需要低成本的穩定通信，Modbus RTU 是理想選擇。 如果需要高速、大規模、靈活的通信環境，特別是需要與 IT 系統集成，選擇 Modbus TCP 更為合適。 RS-485 簡介 由 RS-485(A) / RS-485(B) 2 線組成的雙絞線，傳遞差分訊號 常用硬體是 MAX485 晶片，可將 UART TX/RX 信號轉為 differtial 差分信號。 接收端判斷 2 線 A-B 的結果即可判斷數位訊號為 High(又稱 Mark) 或者 Low(又稱 Space)。 為半雙工模式(Half-Duplex)，同一條總線上在任一時刻只有一個設備作為驅動器，其餘設備均作為接收器： 主站請求時，主站是驅動器，從站是接收器。 從站回應時，某一個從站成為驅動器，主站和其他從站是接收器。 RS-485 設計為 Multi-Drop 多設備共用總線的 Bus topology。 其需要 2 個終端電阻施加在 Bus 兩側末端，跨接在 A 與 B 線上避免 signal reflection，這是 Bus topology 常見作法。 限制: 標準的 RS-485 BUS 上的裝置數量上限為 32 台。 優點:\n因為是雙絞線差分信號，所以抗干擾性強，可以傳輸距離更遠。但須注意 cable length 跟 baudrate 以及裝置數量是相互影響的。 比起 RS-232 point-to-point topology，RS-485 的 Multi-drop 架構可以多裝置連接共用總線。 接線簡單，就 2 條線即可，不需要共地，因為是差分訊號，接收端只需要比較兩線的電壓差異，即可判斷訊號，傳送端跟接收端的電壓基準是不是相同並不重要。 (然而，若訊號出現問題還是可以試著共地試試。) 對於程式開發者來說非常方便，就是直接控制 UART 晶片而已，所以也需要配置 UART 設定，比如 baudrate。 Modbus-RTU 協議 這邊不會詳細列出 request 跟 response 格式，因為 Modbus 協議很簡單，Modbus Specification 也舉例的蠻清楚，只要找裝置實際操作，對照 spec 看基本很容易就可以理解。 因此這邊主要提供一些 Diagram，透過圖片勾勒出基本概念。 本文章主要討論的對象是 Modbus-RTU，為了撰寫方便，若有未表示協議類型的 Modubs 簡稱，請默認其為 Modbus-RTU。\nModbus Frame Modbus 封包共分 4 大部分:\nSlave Address (固定 1 byte) Function Code (固定 1 byte) Data (n Bytes)，Data field 依照不同 function code 會有不同的長度 CRC (固定 2 bytes) 重點提要\nModbus 整個封包上限為 256 bytes，扣掉其他固定大小的部分，Data 部分的變動範圍就是 0 ~ 252 Bytes。 封包一定是 Bytes 倍數，不會有零星的 bits，就算只操作 1-bit 的 coil，也會以 0 補滿傳遞 1 個 Byte。 Modbus-RTU 為 Master/Slave 架構，只能有一個 Master，故 Master 無須地址，但每個 Slaves 有唯一地址。Slave Address 由 1 byte 表示，其中 1-247 可使用，其餘保留給特殊用途。 Function Code 用來表示 Master 要 Slave 做什麼，針對 Slave Register Map 哪個類型部分; 讀 或 寫 ; single 或 multiple 操作。 Data 資料則是依據 Function Code 以及 request/response 需要，而有不同內容。 Modbus 採 CRC-16，而 CRC-16 有很多種，Modbus CRC 採用其中一種，有許多網路工具提供 CRC 計算，此工具經過測試沒問題。 CRC 是由前三個部分的數據計算而得的，照著 Slave Address, Function Code, n Bytes of Data 的順序輸入計算工具即可。 CRC-16 的 Low-Byte 先傳， High-Byte 後傳。(See page 113 of Modbus Specification) 傳送順序\n任意 Byte 中，必定是 Least Significant Bit 先傳，最後是 Most Significant Bit，即照 UART Protocol 順序。 至於 Data Field 超過 1 Byte 以上的資料，就照 [Modbus Specification] 規範，每個 function code 的 request / response 都有清楚規範 Data Bytes 傳送順序。 CRC-16 的 2 Bytes 資料，規範是 Low-Byte 先傳， High-Byte 後傳。 Function Code Function Code 用來表示 Master 要 request Slave 做什麼，\n針對 Slave Register Map 哪個類型部分 讀 or 寫 是 single or multiple 操作。 Modbus Slave Register Map Slave Register Map 分為 4 個部分:\nDiscrete Output = Coil (1-bit) Discrete Input = Contact (1-bit) Input Register = Analog Input (16-bits, 2 words) Holding Register = Analog Output (16-bits, 2 words) Slave 設計 Register Map，告知 Master 自己數據資料格式。Master 透過 function code 即可指定對 Slave Register Map 哪一部分的資料進行讀或寫。由上圖可看到 I/O Address Name 前綴第一個數字即代表 Slave Register Map 類型，比如說 4xxxx 代表 Holding Registers。\n而封包 PDU 之中指定的 address，是相對於 function code 指定操作對象(Slave Register Map 4 個部分之一)的相對位址。比如 function code 為 6; PDU Address 給 2 的話，那就是針對 Holding Register 區域 offset 2 的位置，即操作 Register Map 40003 (40001 + 2) 這個 Holding Register。\nModbus 本質是資料交換 protocol，不過從 Modbus Slave Register Map 4 個部分之命名方式，隱含其與 PLC I/O 的連結，如 coil, contact, analog in, analog out 等等。 源於歷史，當初設計這個 protocol 就是把 Slave 設計為擴充 Master 之 I/O 而生，Master 操作 Slave 猶如操作自己的 Coils 或 Contacts。\n但既然 Modbus 本質是資料交換，那 Slave 端 Register Map 自然不限於跟 Coils 與 Contacts 交互，資料交換後得以進行任意運算或其他 I/O 操作。\nMaster request Coils 或 Holding Registers 部分，資料流就是 : Master -\u0026gt; Slave。 Master request Discrete Inputs 或 Input Registers 部分，資料流就是 : Slave -\u0026gt; Master。 Modbus RTU 之傳輸時間間隔 封包與封包之間要有 3.5 chars 的傳輸間隔 Modbus RTU 協議規定相鄰的 Modbus frame 之間，必須有 「3.5 字元的傳輸時間之空閒間隔」來分隔封包：\n主站發送請求後，總線必須空閒至少 3.5 字元時間，從站才能開始回應。 從站回應完成後，總線也需要維持 3.5 字元的空閒時間，主站 下一次請求才能發送。 在該時間區間內，master 與 slave 不做任何動作。 如果空閒間隔小於 3.5 字元時間，可能導致設備認為兩個 Modbus frame 是連續的一部分，從而發生解析錯誤。\n3.5 字元時間如何計算？\n以 UART 9600N81（8 個數據位元，無校驗位元，1 個停止位元）為例：\n每個字元需要的時間： (1 起始位 + 8 數據位 + 1 停止位) / baudrate = (1 + 8 + 1) / 9600 秒 = 1.0417 毫秒/字元 3.5 字元的傳輸時間： = 3.5 × 1.0417 毫秒 ≈ 3.646 毫秒 字符傳送速度跟 UART baudrate 有關，跟封包大小無關。\nModbus RTU 的規定 Modbus frame 是連續發送的，中間不應有超過 1.5 字元的空閒時間 Modbus RTU 要求 Modbus frame 內的所有字節必須無間斷發送。 若 Modbus frame 中間有超過 1.5 字元的空閒時間，接收端會認為該 frame 已經結束，並將剩餘部分當作下一個 Modbus frame 的開頭。\nExample 實驗步驟\n在 Modbus RTU Slave 內部實作了 2 個 coils。\n先以 Function Code 0x0F Write Multiple Coils，將第 1 個 Coil 寫 \u0026lsquo;0\u0026rsquo;，第 2 個 Coil 寫 \u0026lsquo;1\u0026rsquo;。\n再以 Function Code 0x01 Read Coils 讀取，將得到 Coils 讀值為 0x02。\n幾點觀察:\n在指定 PDU Data Address 以及 quantity 時，都是 High-byte 先傳再來才是 Low-byte。 quantity 單位是看傳什麼資料，若操作對象是 coil，那 quantity 代表多少 coils; 若操作對象是 holding register，那 quantity 則代表多少 holding registers。 傳送 Data Value 時，若超過 1 byte，則是先傳 Data Address 指向的那筆資料，以 little-endian 的記憶體存放來說，那就是先傳 Low-Byte 的資料。 CRC 則是 Low-byte 先傳再來才是 High-byte。 至於每個 Byte 都是從 LSB 開始傳，最後才是 MSB，以上規範在規格書中都寫得很清楚。\n不過一般使用者不需要了解那麼深入，只需要知道要放什麼資料即可，通常給使用者輸入的介面都是很友善的。\n實測 測試目的與方法 為了要驗證對於 protocol 了解的是否正確，一定要實測看看，所以找了現成的 Modbus-RTU Master 與 Slave 來測試。為了方便測試，Master 找了跑在 PC 上的 UI 程式，方便操作; 而 Slave 則找 Arduino 程式，畢竟手邊有許多 Arduino 裝置，若想測試多台 slaves 的 bus topology 會比較方便。\n在 Windows PC 用 QModMaster 作為 Master 測試 Arduino Modbus RTU Slave 功能，測試 QModMaster 支援之 Function code: 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x0f, 0x10。對照 Modbus Specification 手冊查看通訊格式，實測 Modbus-RTU Master 與 Slave 運作是否正確。\n測試環境 因為手邊沒有 USBto485 裝置，所以僅使用 USB2UART 裝置，但我想對於測試 Modbus-RTU 效果是一樣的，只可惜無法像 RS-485 一樣測試多裝置。 PC Modbus Master 軟體 - QModMaster 簡單好用，支援 Modbus-RTU 與 Modbus-TCP，目前僅測試過 Modbus-RTU 部分。 基於 Qt-based UI 及 libmodbus Modbus Library。 Arduino Modbus Slave 韌體 - Arduino Modbus RTU Slave Example 作者為: C.M.Bulliuer\n程式架構簡單，但需要好幾個 libraries 才能運作，compile 不過只要依照缺少 library 之提示，透過 library manager 一一下載即可。下圖為需要之相依程式庫:\nCode 原始範例程式透過巨集定義是可以運行在多個平台的，只是為了呈現簡便，我只保留與我測試平台相關的部分。\n#include \u0026lt;ModbusRTUSlave.h\u0026gt; #if defined(__AVR_ATmega328P__) || defined(__AVR_ATmega168__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega1280__) #define MODBUS_SERIAL Serial #else #define MODBUS_SERIAL Serial1 #define MODBUS_BAUD 115200 #define MODBUS_CONFIG SERIAL_8N1 #define MODBUS_UNIT_ID 10 const int16_t buttonPins[2] = {2, 3}; const int16_t ledPins[4] = {5, 6, 7, 8}; const int16_t dePin = 13; const int16_t knobPins[2] = {A0, A1}; ModbusRTUSlave modbus(MODBUS_SERIAL, dePin); const uint8_t numCoils = 2; const uint8_t numDiscreteInputs = 2; const uint8_t numHoldingRegisters = 2; const uint8_t numInputRegisters = 2; bool coils[numCoils]; bool discreteInputs[numDiscreteInputs]; uint16_t holdingRegisters[numHoldingRegisters]; uint16_t inputRegisters[numInputRegisters]; void setup() { pinMode(knobPins[0], INPUT); pinMode(knobPins[1], INPUT); pinMode(buttonPins[0], INPUT_PULLUP); pinMode(buttonPins[1], INPUT_PULLUP); pinMode(ledPins[0], OUTPUT); pinMode(ledPins[1], OUTPUT); pinMode(ledPins[2], OUTPUT); pinMode(ledPins[3], OUTPUT); modbus.configureCoils(coils, numCoils); modbus.configureDiscreteInputs(discreteInputs, numDiscreteInputs); modbus.configureHoldingRegisters(holdingRegisters, numHoldingRegisters); modbus.configureInputRegisters(inputRegisters, numInputRegisters); MODBUS_SERIAL.begin(MODBUS_BAUD, MODBUS_CONFIG); modbus.begin(MODBUS_UNIT_ID, MODBUS_BAUD, MODBUS_CONFIG); } void loop() { inputRegisters[0] = analogRead(knobPins[0]); inputRegisters[1] = analogRead(knobPins[1]); discreteInputs[0] = !digitalRead(buttonPins[0]); discreteInputs[1] = !digitalRead(buttonPins[1]); modbus.poll(); analogWrite(ledPins[0], holdingRegisters[0]); analogWrite(ledPins[1], holdingRegisters[1]); digitalWrite(ledPins[2], coils[0]); digitalWrite(ledPins[3], coils[1]); } Architecture User 為 Slave Register Map 的 4 個部分分別定義 Array 空間，並透過 configure...() 函式與 Register Map 綁定。 Configure 完畢後，使用者只須要操作自己定義的變數空間(user defined variables)，無須去操作 Slave Register Map。\nSlave 由 Modbus.poll() 函式，將 Slave Register Map 資料透過 Modbus 交換。\nconfigure...() 等相關 configure API 只能設定一次，無法分次設置，所以必須一次給好完整空間。 這點比較可惜，因為我總想為 IO 設定有意義一點的名稱，比如 LED, fan 等等名稱，不想統統用 coils[] array 表示。\n結果 經過測試兩者運作無誤，透過 Modbus Protocol，Master 可以 request 控制 Slave 不管是數位或類比之輸入輸出。 QModMaster 以及 Arduino Slave Example 都很簡單也成功通過測試，可以作為 Modbus 學習參考工具。 若未來要自己實現自己的 Modbus-RTU Master 或者 Slave 裝置，都可以用這些工具交叉驗證。\n延伸討論 為何 Modbus 使用 RS-485 僅支持 32 個設備？ 先說結論: 這是 RS-485 的物理層特性 的限制，而非 Modbus。\nRS-485 的設備數量限制與其驅動能力有關： 每個設備（包括主站和從站）會對通信總線施加一定的負載，通常以 \u0026ldquo;單位負載（Unit Loads，UL）\u0026rdquo; 表示。 RS-485 總線上的每個裝置都是一個負載，RS-485 標準規範規定，驅動器必須能驅動 32 單位負載 。 每個負載會對總線施加一定的電氣負載，這些負載的累積不能超過驅動器的能力。意思是: 其中 1 台裝置作為驅動器 (Driver/Transceiver)發送訊號時，需要推動至少 31 台接收器 (Receiver)。\nDriver（驅動器）：負責在 RS-485 總線上發送信號的設備，通常是主站或從站在某一時刻充當的角色。 Receiver（接收器）：負責接收來自總線上的信號的設備，驅動器之外的都是接收器。 擴充方法:\n現代 RS-485 晶片可能是低負載（Low-Load）設計（例如 1/4 UL 或 1/8 UL），這允許更多的設備接入，可以將設備數量增加到 128 或更多。 如果接收器的負載是 1/4 UL，每個驅動器可以支持多達 128 個接收器（32 UL ÷ 1/4 UL = 128）。 如果接收器的負載是 1/8 UL，每個驅動器可以支持多達 256 個接收器。 或使用 中繼器(Repeater) 可以增加總線上的設備數量，同時擴展通信距離。 中繼器將 RS-485 網絡分段，增強信號並重新驅動。 每段網絡的設備數量仍受 1 驅動器 + 31 接收器的限制，但中繼器可以增加網絡的總設備數量。 Modbus 協議層的限制 Modbus 協議層限制了 ID 的範圍，Modbus 的從站地址（Slave ID）為 1 Byte，其中 0、248-255 保留作其他用途（如廣播地址和未來擴展），其實際 Slaves 地址範圍為 1-247。\n5. 總結 Modbus 搭配 RS-485 時只能有 32 個設備是受制於 RS-485 物理層的能力。\n\u0026ldquo;1 驅動器 + 31 接收器\u0026rdquo; 是 RS-485 在標準單位負載情況下的最大設備配置。 使用低負載接收器或中繼器可以增加網絡容量。 在實際應用中，信號完整性（如終端電阻和線路長度）也是限制 RS-485 設備數量的重要因素。 Modbus ASCII 和 Modbus RTU 比較 這是 Modbus 協議的兩種傳輸模式，它們的主要區別在於數據編碼、傳輸速度以及處理方式。以下是它們的比較：\n數據編碼：\nModbus ASCII：數據是以 ASCII 字符格式傳送，每個字節都會轉換為兩個 ASCII 字符來表示。例如，字節 0x0A 會被傳送為兩個字符 0、A（十六進制）。 Modbus RTU：數據以二進制格式傳送，每個字節直接傳送 8 位數據。因此，Modbus RTU 在數據編碼上比 Modbus ASCII 更為高效，因為它不需要額外的字符轉換。 傳輸效率：\nModbus ASCII：由於每個字節需要被轉換成兩個 ASCII 字符，因此其傳輸效率較低，數據量更大，傳輸速度相對較慢。 Modbus RTU：由於使用的是二進制格式，數據量較少，傳輸速度較快，因此比 Modbus ASCII 更有效率。 同步機制：\nModbus ASCII：每個消息的結尾通常會有一個字符 CR（回車）和 LF（換行）來標誌結束，這樣可以幫助接收方識別消息結尾。 Modbus RTU：消息的結尾是由固定的時間延遲來確定，通常是無線消息之間有至少 3.5 個字符時間的間隔來標識一個消息的結束。 錯誤檢測：\nModbus ASCII：使用 16 位的 LRC (Longitudinal Redundancy Check) 校驗來檢查數據是否完整。 Modbus RTU：使用 CRC (Cyclic Redundancy Check) 校驗，它比 LRC 更強大，更適合長距離的數據傳輸。 總結來說，Modbus RTU 在大多數情況下都比 Modbus ASCII 更為高效，基本上現在很少在用 ASCII 模式，因此可以專注在 RTU 模式即可。\nReferences Modbus Specification QModMaster Arduino Modbus RTU Slave Example ","permalink":"https://wsmao.github.io/post/modbus/","tags":["Fieldbus"],"title":"Modbus-RTU"},{"categories":null,"contents":" 前言: 從第一性原理的角度理解: PLC 的 S/S 腳位 如何判斷 PLC 類型 補充: 若 Output 端為繼電器 Relay，則無方向性限制! 前言: NPN / PNP 是電晶體類型，而對於 PLC 產品的使用者來說更重要的是其接線方式。當 Output 端採用電晶體控制輸出時，電晶體類型 NPN / PNP 影響著電流的方向性，故接線方式要照著電晶體類型來接，市面上一些自動化 Input / Output 裝置標榜自己是 NPN 或 PNP 目的在告訴消費者接線方法。\nOutput 跟 Input 是相對概念，\n當 PLC 作為 Output 時，由 Y 腳位輸出，其接受對象就是 Input 端，例如燈泡。 當 PLC 作為 Input 時，由 X 腳位輸入，為某種 Output 端的輸出對象，例如 Sensor。 Input 作為 Output 之受體又稱之為負載。 從第一性原理的角度理解: 理解 NPN / PNP 的電流方向性就能理解接線方式 不管哪種類型，輸出端通常都採用 open collector 方式接到輸入端。 這是 Output 端為 NPN 電晶體的電流方向，由此可看出作為其負載(Input 端) 應該怎麼接線。\n這是 Output 端為 PNP 電晶體的電流方向，由此可看出作為其負載(Input 端) 應該怎麼接線。\n上面提到了，當 Output 端採用電晶體控制輸出時，其電晶體類型 NPN 或 PNP 決定了電流方向。接線必須照著接才可驅動:\nNPN(又稱為 Sink) 這個架構下的搭配組合稱為 NPN Output / NPN Input 電流流向為: Input 端 -\u0026gt; Output 端 PNP(又稱為 Source) 這個架構下的搭配組合稱為 PNP Output / PNP Input 電流流向為: Output 端 -\u0026gt; Input 端 其中 Source / Sink 的概念應是以 Output 端的角度出發:\nOutput 為 Source 提供電流源。 Output 為 Sink 則是接收電流源。 PLC 的 S/S 腳位 S/S 腳位是 souce/sink 的縮寫。\n如前所述所述，NPN 類型的輸入裝置，就要搭配 NPN 類型的輸出裝置。故要看 PLC 的輸入類型，決定要買哪種類型的 Sensor 搭配使用，反之亦然。\n不過有些 PLC 提供了 S/S (Source/Sink) 腳位，那代表 NPN / PNP 兩種 Sensor 都支援。 如果沒有提供 S/S 腳位，代表其只支援一種輸入方式，這樣就得對照買 NPN 或 PNP 型的 Sensor 了。 下圖是提供可設定 S/S 腳位的 PLC，使用者可以看 Sensor 類型決定使用哪種配置。\n如何判斷 PLC 類型 有使用手冊自然是看使用手冊。\nPLC 輸出端，看是 Relay 型還是電晶體型，電晶體行就要查是 NPN 或是 PNP。 PLC 輸入端 可以看一下是否有 S/S 腳位可以設定，有的話就可自行設定為 Sink or Source。 如果輸入端的形式是固定的，那也可以量測 X 點就可以知道需要哪種感測器， 如果是量到 GND，那代表 S/S 是接到 GND，所以你需要買 PNP 型感測器。 反之，就代表你需要買 NPN 型感測器。 一般來說，台日韓機台都是用 NPN 比較多，歐洲機台則是 PNP 型的比較多 補充: 若 Output 端為繼電器 Relay，則無方向性限制! Relay 不像 Transistor 有電流的方向性，作為一個沒有方向性的開關，可以配合任何類型的 Input 裝置。\n一般繼電器都除了 COM 點，都會提供 NO(Normal Open / a接點) 與 NC(Normal Close / b接點) 2種腳位讓使用者可以自己選擇要使用哪種。\n不管哪種，一定都有共同的輸入源，稱為 COM 點 當 Realy Coil 沒有通電激磁，則 COM 點與 NC 腳位連接，與 NO 腳位斷開。 當 Realy Coil 通電激磁，則 COM 點與 NO 腳位連接，與 NC 腳位斷開。 總之，使用 Relay 的好處之一，就是沒有方向性。\n若搭配的是 NPN Input 裝置，那 Sink 的電流方向就是由 input 端 -\u0026gt; output 端，COM 點就得接到 GND，NO 腳位接到輸出 Y 。 若搭配的是 PNP Input 裝置，那 Source 的電流方向就是由 output 端 -\u0026gt; input 端，COM 點就得接到 VCC，NO 腳位接到輸出 Y 。 另外 Relay 還有個優點，就是可以接交流電，這也是電晶體做不到的。\n","permalink":"https://wsmao.github.io/post/plc_npn_pnp/","tags":["PLC"],"title":"PLC NPN 與 PNP 接線概念"},{"categories":null,"contents":" 前言 為什麼需要 Bootloader？ 方法 準備 開始 Step1: 先將 Arduino ISP 程式燒錄到要作為 Programmer 的 Arduino。 Step2: 為 Atmega328P 搭建電路 Step3: Programmer 跟 Atmega328P 連接 Step4: 燒錄 Bootloader Step5: 測試 Bootloader 是否正確運作 結論 補充 何謂 ISP？ Arduino IDE 選單操作: 燒錄 Bootloader 與 Sketch 選擇與電腦通訊的 Port 選擇目標板 燒錄 Bootloader 會用到的選單 透過 Bootloader 上傳程式 Reference 前言 這篇文章會分享如何為一個全新的 Atmega328P IC 燒錄 Bootloader，以便之後的開發進行。\n為什麼需要 Bootloader？ Arduino 之所以能夠輕鬆的透過 USB 將寫好的 sketch 程式一鍵上傳，這都要歸功於內部的 Bootloader Firmware。Bootloader 顧名思義就是啟動載入器，開機時會優先執行 bootloader 再由它判斷下一步要做什麼，若有燒錄的請求就引導燒錄進行，若沒有則會執行舊的 sketch 程式。\n若沒有了 Bootloader 的幫忙，則只能透過 Programmer 對 MCU 進行燒錄，就得準備一台 Programmer 才能為 Arduino 燒錄，開發過程就沒那麼方便了。\n然而當你單獨購買一個 Atmega328P MCU 時，廠家不一定會幫你預先燒錄 Bootloader，我們就得自行燒錄，而 Bootloader 的燒錄，還是得透過 Programmer 才行。\n所以這篇文章就是要寫如何透過 Programmer 來為 Atmega MCU 燒錄 Bootloader。有了 Bootloader 之後，我們只需連接一條 USB 就能上傳程式。\n方法 由於要燒錄 Bootloader 一定得透過 Programmer 幫忙，而一般使用者通常不會有，所以我們用另一種方式，就是把手邊的 Arduino 變成 Programmer，稱之為 Arduino ISP。\n接著我們要用麵包板為 Atmega328P MCU 搭建基本的工作電路，讓他得以運作，接受 Programmer 的燒錄。\n如此，我們就能透過一台 Arduino ISP 為 Atmega328P MCU 燒錄 Bootloader。\n準備 1 塊 Arduino，作為 Arduino ISP。 MCU 基本工作電路\n1 個 Atmega328P MCU 2 個電容： 22pF 1 個振盪器: 8~16 MHz 開始 Step1: 先將 Arduino ISP 程式燒錄到要作為 Programmer 的 Arduino。 這邊我以手邊的 Arduino Leonardo 為例：\n打開 Arduino ISP 範例程式：\n將 Leonardo USB 與電腦連接後，選擇 Leonardo 並選擇正確的 Port 即可上傳。\n上傳後這塊 Leonardo 就是 Programmer 啦，USB 不用拔掉，放著待會繼續用。\nStep2: 為 Atmega328P 搭建電路 Atmega328P IC 需要最基本的工作電路才可以運作，像是電源、震盪器等等。\nAtmega328P (IC Pin) 接法 pin7(VCC) 連接至 5V pin8(GND) 連接至 GND pin9 (OSC1) 連接至震盪器其中 1 隻腳位，再連接電容至 GND pin10 (OSC2) 連接至震盪器另 1 隻腳位，再連接電容至 GND pin19 (BUILTIN_LED) 連接至 LED [ ] TODO， 補上電路圖會更清楚些\n【Alternative】其實還有個做法，如果手邊有另一塊可替換 IC 的 Arduino UNO 板子，那麼上面 Atmega328P IC 底座是可以插拔的，只要把舊 IC 拔起來，換上目標 Atmega328P 那就可以直接利用這塊現成電路啦!。只不過這篇文章想介紹自己動手搭建基礎工作電路的方式，如果手邊有可替換 IC 的板子可以自己選擇要怎麼做哦。\nStep3: Programmer 跟 Atmega328P 連接 線路連接:\n這是 Arduino Leonardo 作為 ISP 對 Atmega328P 燒錄的接線方式，換做其他板子也是一樣。\nProgrammer (Leonardo) Target (Atmega328P) Digital Pin 10 Reset Pin (pin 1) ICSP MOSI ICSP MOSI (pin 11) ICSP MISO ICSP MISO (pin 12) ICSP CLK ICSP CLK (pin 13) 有些教學會教，可以使用板子上的 11、12、13 去做連接，這是因為 Arduino UNO 板子上這幾隻腳與 ICSP 腳實際是有連通的。不過 Arduino Leonardo 並沒有，所以若想使用 Arduino Leonardo as ISP，且想照某些範例使用 11、12、13 這幾隻腳位，也是可以，不過必須在 ArduinoISP.ino 內 uncomment 這一行 // #define USE_OLD_STYLE_WIRING，這樣就可以使用這幾隻腳作為 ISP 腳位了，但是必須知道這樣實際使用的是 Software SPI，而非 Hardware SPI，所以還是建議不要多此一舉，乖乖地使用 Leonardo 板子上的 ICSP 腳位就好，不用改程式且因為這是硬體 SPI 腳位,所以快又穩。\nStep4: 燒錄 Bootloader 選擇目標板子： 因為是對 Atmega328P 燒錄，所以目標板子就選擇也是使用 Atmega328P 的 Arduino UNO。\n選擇 Port: 因為實際跟電腦連接的是 Leonardo，所以選擇 Leonardo USB Port。\n選擇 Programmer: Tools -\u0026gt; Programmer -\u0026gt; Arduino as ISP (Atmega32u4)\n最後按下 Tools -\u0026gt; Burn Bootloader 即可。\nStep5: 測試 Bootloader 是否正確運作 測試 Bootloader 的方式很簡單，只要接上 USB 並且可以看到 Serial Port 出現，那大概就是有成功了，不過我們可以更進一步上傳程式看看。\n可惜，用麵包板搭建最基本的工作電路，就沒有 USB 可以用了。 但沒有關係，對於 Arduino UNO 而言，其 USB 其實是連結到板上另一顆 USB2UART 晶片，再接到 UART 腳位，換句話說，裝置與電腦透過 USB 連接，最終卻是連結 Atmega328P 的 UART 腳位接收上傳程式。 這代表我們可以直接利用外接的 USB2UART 板子，將 USB2UART 的 tx rx 跟 Atmega328P 上的 UART 對接（之間有各加 1 個 1K 電阻），也要可以順利上傳程式才對!\n上傳程式時，我們還需要對板子 reset，讓板子 reset 後進入 bootloader 引導後續上傳。reset 方式有很多種，UNO 板是用 DTR 訊號自動在上傳時對目標板子做 reset，這個自動 reset 機制很酷也很有趣，但可以討論的東西不少，我想可以以另一篇文章深入探討。\n我們只需要讓 Atmega328P 的 reset pin 在需要 reset 的時候接到 GND，就可以做到 reset。 這邊我們先土炮一點，用一個 reset button 配一個 pull up resistor 來實現:\n按下 button 時，reset pin 會 short to GND，導致板子 reset。 放開 button 時，reset pin 被 pull up to Vcc，維持工作狀態。 記得按的 timing 要抓一下，畢竟我們是手動控制，大概按下上傳後看到 IDE 在等待的時後（等待裝置 reset）趕快按下去再放開，如果 bootloader 順利運作就能上傳成功啦!\n【Alternative】用可替換 ic 的 Arduino UNO 板子 只要將燒好 bootloader 的 Atmega328P 放上 Arduino UNO 28 pins 底座，然後用 USB 線嘗試 upload sketch，若可上傳代表 bootloader 運作 ok。\n結論 通常只有當板子上沒有任何韌體時或者板子韌體毀損或者有特殊需求，才會透過 ISP 燒錄，不然一般只需透過 ISP 燒錄一次 bootloader，有了 bootloader 後，只需連接 USB 就可以一鍵上傳 sketch 了，非常方便。\n補充 何謂 ISP？ ISP 是 In-System-Programming ，代表無需將 ROM 從板子上取下，而是直接在板子完整的系統上進行燒錄。\nAVR 微控制器內部的 ISP 模組設計是基於 SPI 接口。燒錄時，程序數據透過 MOSI（Master Out, Slave In） 傳送到微控制器，並從 MISO（Master In, Slave Out） 回應，時鐘信號由 SCK（Serial Clock） 提供。只要將 Programmer 與 Arduino 的 ISP 介面連接即可燒錄。\nArduino IDE 選單操作: 燒錄 Bootloader 與 Sketch 選擇與電腦通訊的 Port 通訊埠 Port 是與電腦連接之裝置所使用的通訊埠端口，而不同情境下，連接至電腦的可能是：\nArduino 板子： 有 bootloader 的裝置得以直接用 USB 連接至電腦，直接上傳 sketch 程式。 Programmer 板子： 當程式要透過 Programmer 上傳時，則 Programmer 裝置以 USB 連接至電腦。 USB2UART 板子： 當想要直接讓電腦跟 Arduino 用 UART 溝通時，則可透過 USB2UART 連接，這樣就是 USB2UART 模組與電腦連接。 選擇目標板 目標板，就是要接收新程式的板子，因為不同型號的板子會有不同的軟硬體配置，所以需要選擇正確的板子。 注意，如果透過 A 板子作為 ISP 燒錄 B 板子，那目標板子要選 B 板子的型號才是，因為 B 板才是新程式的受體。\n燒錄 Bootloader 會用到的選單 燒錄 Bootloader 只能透過 Programmer，而 Programmer 有很多種，運作方式可能有差異，所以要選擇使用哪一種 Programmer。\n到 Tools -\u0026gt; Programmer -\u0026gt; ...) 選擇 Programmer。 按 Tools -\u0026gt; Burn Bootloader 上傳 透過 Bootloader 上傳程式 按 Sketch -\u0026gt; Upload 上傳。\n透過 Programmer 上傳程式 到 Tools -\u0026gt; Programmer -\u0026gt; ...) 選擇 Programmer。 按 Sketch -\u0026gt; Upload Using Programmer 以 programmer 上傳。 注意： 若用 Programmer 燒錄 Sketch 程式，則 Bootloader 就會被洗掉 (所以看起來用 Programmer 就是整個 Flash 重燒，無法保留 Bootloader 只燒錄 App)。 因此對於新的 ATmega328p 板子要像 UNO 板子一樣運作的話，還是要燒 Bootloader，之後就使用 Bootloader 上傳 Sketch 程式就好了。\nReference ATmega328P pinout Arduino Leonardo pinout ","permalink":"https://wsmao.github.io/post/flash_arduino_bootloader/","tags":["Arduino"],"title":"How to Flash Arduino Bootloader into a new Atmega IC."},{"categories":null,"contents":"磁力哪裡來? 我們知道電荷運動會產生磁力。物質的磁性即是因為原子內部質子、電子運動產生的微小磁力所疊加起來的效果。\n當物質內部電子運動方向雜亂，產生之磁場相互抵銷，疊加起來就不具有外顯磁性。 而當物質其電子被某種方式排列成特定方向，產生一致的磁性方向，疊加起來就有明顯之磁力表現。 磁化 磁化就是使原本不具有外顯磁性的物質產生磁力。\n退磁 退磁，與激磁相反，因為高溫或撞擊，破壞了原本整齊排列的磁矩，導致磁性消失。\n天然磁石、人造磁石、電磁鐵 天然磁石 天然磁石（也稱磁鐵礦，學名為 Fe₃O₄）是自然界中存在的一種含鐵氧化物礦石，這種礦石是地球在地質過程中天然形成的產物，其磁性是地球內部化學反應和地磁場作用的結果。\n地球內部含有大量的鐵和氧元素，在地質活動（例如火山噴發或隕石撞擊）中，在高溫高壓條件下，這些元素化學反應生成鐵的氧化物，岩石受到強磁場影響，進一步增強了磁性。\n人造磁石 人造磁石則是通過將適合的材料加熱到居里溫度以上，再施加磁場使材料內部分子的磁矩整齊排列，保持這種排列到冷卻後即可產生持久的磁力。\n電磁鐵 電磁鐵則是由線圈激磁而產生暫時性的磁立。\n天然磁石與人造磁鐵的比較 特性 天然磁石 人造磁鐵 來源 自然形成 人為加工製造 磁性強度 弱，磁性不穩定 強，磁性穩定 材料 Fe₃O₄（磁鐵礦） 釹鐵硼、鋁鎳鈷、鐵氧體等 用途 古代指南針、觀察地磁特性 電機、揚聲器、工業設備等 問問 Q: 未被磁化，亦沒有通電線圈的鐵片為什麼可以被磁鐵吸附?\nA: 鐵是容易被磁性物質改變磁力方向的原素，因此當磁力物質靠近鐵時，之所以能夠彼此吸引，是因為鐵瞬間被磁化而具有暫時性的磁力。\nReferences 為什麼磁鐵只會對鐵產生吸引力？而沒有磁金？磁銀？磁銅呢？\n人造磁鐵是怎麼製作的？磁性從哪裡來？看完長見識了\n","permalink":"https://wsmao.github.io/post/%E7%A5%9E%E5%A5%87%E7%9A%84%E7%A3%81%E5%8A%9B/","tags":["Science"],"title":"磁力是一種魔力"},{"categories":null,"contents":"前言 555 是偉大的 IC，簡單而實用，不時可以看到它的應用出現在生活之中。因此，我想來好好學習有關這顆 IC，做一些實驗以及 Demo 出來玩玩。\n但凡簡單的東西必不簡單，身為一個電子電路門外漢，我想從一些基本的概念學起，用我的角度來紀錄學習，希望能幫到跟我一樣的電子小白。\n緣起 其實會研究這個 IC 是因為學習 PLC 的過程中，不斷看到 Univibrator 這個詞。由於 PLC 是可程式化控制器，會提到這個詞大概就是指能夠撰寫 PLC 程式，利用 PLC 元件，使 PLC 控制器做到振盪器電路所做的事情。\n本文概要 本篇文章不打算探討 PLC，而是打算從底層從電子元件出發，深入振盪器電路相關之概念。 而 555 IC 非常適合用來做這個主題的實驗，了解一些基本概念並從 555 IC 內部核心架構出發。\nHow a 555 Timer IC Works\n名詞 Univibrator：是早期用來特指「單穩態電路」的名稱（因為它只有一個穩定狀態，符合 \u0026ldquo;uni-\u0026rdquo; 的含義）。 後來，隨著概念擴展，有時 Univibrator 被用來泛指單穩態（monostable）和雙穩態（bistable）的電路，但這樣的用法不太精確。\nMultivibrator: 是指所有基於穩定狀態切換的振盪器電路，包括\n單穩態（Monostable Multivibrator），只有一種狀態是穩定的，其餘都是不穩定的，可以由某種方法使其進入暫態，但過時一段時間還是會回到穩定狀態。 雙穩態（Bistable Multivibrator） 非穩態（Astable Multivibrator） Flip flop: 就是指 Bistable 電子開關 switch，有 ON/OFF 2 個 stable 狀態，是 bi-stable operation。\nRS flip flop(2 個 NOR gate 即可兜出) D flip flop JK flip flop T flip flop combinational logic: whose output is a function of only the present inputs.\nsequential logic: whose output depends not only on the present input values but also on the past history.\n555 IC 內部架構 555 IC\n內部有兩個比較器：一個比較上閥值（2/3 VCC），另一個比較下閥值（1/3 VCC）。 比較器將外部的電容充放電電壓與這些閥值進行比較，作為邏輯判斷的依據。 透過幾種接線方式形成常用的三種模式: mono-stable: 持續一陣子的暫態，再回到穩態 (像門口感應燈的應用) bi-stable: 兩種穩態 (RS 觸發器，像電燈開關，ON / OFF) astable: 非穩態，沒有穩定狀態，會產生連續持續的波型 (PWM 電路)。 應用 RC 越大，暫態維持的時間越久。\n","permalink":"https://wsmao.github.io/post/%E5%88%9D%E6%8E%A2_555-ic/","tags":["555-IC","Oscillator","Electronics","IC"],"title":"初探 555-IC，小晶片大用途"},{"categories":null,"contents":" 字符的編、解碼 何謂 Unicode? UTF-8 是? 字形庫 特殊符號的使用 HTML、CSS、JavaScript 如何使用 Unicode 編碼的設定 實用的工具網站 字符的編、解碼 對於電腦而言，每個字符不過是用一串的編碼來表示，比如英文小寫字符 \u0026lsquo;a\u0026rsquo;\n在 ASCII 編碼方式中，以16進位數字 0x61 表示。 在 Unicode 編碼方式則是16進位數字 00000061。 在 UTF-8 編碼方式則是16進位數字 61。 以 VSCode 為例，但包含多數的文字編輯器，都可以選擇儲存的編碼類型，也可以選擇打開文件的解碼類型。當然理論上用什麼編碼儲存就要用相同之解碼器打開 UTF-8 就是一種世界通用的編碼格式，因為它支援所有不同語言使用到的文字，故大多數軟體預設的編、解碼方式都是 UTF-8。\n而瀏覽器也是要讀取 HTML、CSS 等檔案進行渲染，因此也得知道這些檔案的儲存格式，而現在這些檔案多用 UTF-8 來編碼保存，所以瀏覽器也得用 UTF-8 來解碼內容。\n何謂 Unicode? UTF-8 是? 旨在容納世界所有文字符號的國際標準編碼，使用 4 Bytes 為每個字元編碼。 然而這 4 Bytes 實際上是稱作 Unicode 碼位 (Code Point)，雖代表獨一無二的字元，卻並非實際儲存到檔案的編碼。 實際儲存到檔案的則是要看 Unicode 採用哪種編碼格式。\nUnicode 本身不限定存儲方式，但常見的編碼方式有：\nUTF-8（可變長度編碼，1 ~ 4 Bytes） UTF-16（通常用 2 或 4 Bytes） UTF-32（固定 4 Bytes） Unicode 碼位 (Code Point)，雖不是直接儲存的數據，卻可以定位獨一無二的字元，碼位範圍是 U+0000 至 U+10FFFF。\n對於絕大多數常用字符，其碼位都能用 2 Bytes 表示，即 4 個十六進數字表示（範圍在 U+0000 至 U+FFFF）。 因此，可以發現在 HTML、CSS 等檔案中引用 Unicode 字符時，格式都是只用 2 Bytes 的碼位表示，比如說 bullet point 的碼位為 U+2022。\n一律建議使用 Unicode 的 UTF-8 編碼方式 UTF-8 是 Unicode 的一種編碼方式，優勢是每個字符佔用的大小是可變的，根據字符的 Unicode 編號範圍，每個字符所需的字節數從 1 到 4 Bytes 不等，顯而意見的好處是可以節省儲存空間。比如說:\nbullet point 的碼位是 (U+2022)，其 UTF-8 編碼是 3bytes 為：0xE2 0x80 0xA2。 小寫英文字母 a 的碼位是 (U+0061)，其 UTF-8 編碼只佔 1 byte 為: 0x61。 網頁開發者會使用碼位表示字符，而無須直接把 UTF-8 或其他編碼格式的編碼寫出來。\nUTF-8 的優勢 UTF-8 的設計解決了以上問題，主要優勢包括：\n變長編碼，節省空間 常用字符（ASCII 範圍內）只需 1 Byte。 不常用的字符會用 2-4 Bytes 表示，符合實際使用的頻率分佈。 向後兼容 ASCII: 舊系統可以直接讀取 UTF-8 中的 ASCII 字符，而不需要特殊處理，因為 UTF-8 中對 ASCII 字符的編碼一模一樣，也都是 1 byte。 全球化支持: 可以表示所有 Unicode 字符，滿足全球多語言需求。 錯誤檢測能力: UTF-8 的編碼設計能夠檢測許多常見的數據錯誤，提升了數據的可靠性。 字形庫 編碼集 \u0026lt;-\u0026gt; 字形庫 之間的關係為何?\nUnicode 定義了每個字符的 Code Point 碼位。 而對於每一個 Unicode Code Point\nUnicode 定義了其字符意義。 UTF-8 定義了其字符底層編碼 (是幾個 bytes，每個 byte 的值)。 字形庫 定義了其字符形狀。 比如說 Unicode 碼位 U+2022\nUnicode 定義其意義為 bullet point。 UTF-8 定義其編碼為 3 Bytes，編碼值為 0xE2 0x80 0xA2。 根據選用的字形庫則決定了在螢幕上， bullet point 顯示的形狀。 所以真正定義字符形狀的是由字形庫。字形庫會去實現他所支援的 Unicode 碼位的字形，可能是 svg 圖，或者點陣圖等等。 當你套用不同字形庫時，同一個意義的字符可能長得不一樣。 當然，不可能有一個字形庫實現所有的 Unicode 字符，所以要注意自己想要的字符是否可以被多數的字形庫支援，盡量選用支援度高的。\n特殊符號的使用 一般符號，比如說英文的 26 字母，或是中文的字符，都可以靠輸入法輸入編輯器中。 然而，總是有些時候需要一些特殊符號來標註或者作特定使用，然而卻是輸入法或者應用程式沒有直接支援的。 但是 Unicode 包含了所有字符的定義，我們大可去網路上找出該字符，然後在編輯器中使用它。\n程式設計師在撰寫 HTML、CSS 檔案時，可以怎麼使用特殊符號呢? 一樣舉 bullet point 為例:\nCSS 檔案內可以寫 \u0026ldquo;\\2022\u0026rdquo; 也可以寫 \u0026ldquo;•\u0026rdquo;; 第 1 種寫法， CSS 檔案中的 string 內使用 \\ 是 Unicode 的轉譯符號，後面接 4 個位數 16 進制的碼位，表示特定字符。這種把碼位寫出來的方式，需把 \u0026lsquo;'、\u0026lsquo;2\u0026rsquo;、\u0026lsquo;0\u0026rsquo;、\u0026lsquo;2\u0026rsquo;、\u0026lsquo;2\u0026rsquo; 都存入檔案，較占用檔案空間。以 UTF-8 較省空間的編碼保存檔案，也會占用 5 Bytes。\n第 2 種寫法，直接寫 \u0026lsquo;•\u0026rsquo;，好處是省檔案空間，又可以直接看到是什麼符號。然而有時候你的輸入法或者編輯器程式，沒有內建幫你輸入特殊符號的功能，那你就得去找到這個符號來複製，然後用貼上的方式輸入了，這不是什麼問題。但有時候搞不好 vscode 使用的字型不支援這個符號，那就沒有對應的圖形樣式，則無法在編輯器上呈現，這時用第一種作法就比較好。\nHTML、CSS、JavaScript 如何使用 Unicode 不同的語言或環境對於嵌入 Unicode 碼位的書寫格式有不同的要求。 比如 Unicode 碼位 U+2022，即 bullet point 在不同網頁語言下取用方式如下:\n語言/環境 使用方式 解釋 HTML \u0026amp;#8226; HTML 實體，十進制形式。 HTML \u0026amp;#x2022; HTML 實體，十六進制形式。 CSS \\2022 CSS 的簡化 Unicode 表示法，十六進制形式。 JavaScript \\u2022 JavaScript 字符串的 Unicode 表示，十六進制形式。 比如說在 CSS 語言中的字元或字串中輸入\u0026quot;\\2022\u0026quot;，這個格式是 Unicode 轉義序列。\n\\ 是轉義符號，表示接下來是一個 Unicode 碼位。 2022 是十六進制的 Unicode 字符值，對應某個字符的圖標。 編碼的設定 現代的 HTML 預設使用 UTF-8 作為字符編碼，只要在 中指定： \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;\n\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; 的主要目的，是明確告訴瀏覽器這個 HTML 文件使用的字符編碼是 UTF-8，以避免因編碼錯誤導致的文字亂碼問題。 即使文件本身已保存為 UTF-8 格式，仍然需要這個標籤來確保瀏覽器正確解讀文件的內容。 因為如果未在 中明確指定字符集，瀏覽器會根據：\nHTTP 回應頭中的 Content-Type。(如 Content-Type: text/html; charset=ISO-8859-1) 預設的字符編碼（如某些地區設置默認為 ISO-8859-1）。 文件內容 等進行猜測，而如果猜測的編碼與實際編碼不符，就會導致亂碼。\nCSS 本身不直接指定文件編碼，但它繼承 HTML 的編碼環境，一般也都是 UTF-8 啦。\n實用的工具網站 通常實用的做法是直接找字形庫，依照嵌入的方式，複製其字符或者碼位。至於 UTF-8 編碼，對一般使用者來說較不重要，除非你是寫編輯器或瀏覽器的人，不然根本不需要去碰到底層編碼。或者是你單純想看看其編碼為何。\n通常上瀏覽器，搜尋 UTF-8 符號，點開任意連結，複製想要的內容貼上即可。\n工具網站\n字形庫 Themify\n不過這個的缺點是網頁上沒有直接顯示符號對應的碼位，但可以下載後再將字形檔案丟到 Font Drop 就可以查看字符跟 Unicode 位碼對照著看。 但是有支援很多漂亮 icons 可以用阿! 可以看到這些 icons 的位碼，是 (U+exxx) 經查詢屬於 Private Use Area，所以要下載這個字形庫才有支援阿，其他的字形庫不見得有支援這個位碼。 symbol.cc，列出許多 Unicode Symbol。\n除了基本的 Code point，也直接顯示 HTML、CSS、JavaScript 嵌入的格式，相當貼心。 連 Alt Code 都有，在 Windows 下可以按住 Alt 加上 Code 打出特殊文字。 也可切換到 Encoding 頁面看各種編碼。 Font Drop: 支援拖曳 .ttf 或 .woff 文件，檢視所有符號。\n","permalink":"https://wsmao.github.io/post/website_with_utf-8/","tags":["unicode"],"title":"字符的旅程"},{"categories":null,"contents":"今天認識了前澤友作這位傳奇商業奇才，才 40 多歲，身價就高達 36 億美元的日本富豪。\n我感興趣的不是他多有錢，而是他有多特別，想了解他不一樣的人生以及思維。 他可說是說做就做的人，並且幾乎每一樣都可以大獲成功，這點跟 Elon Musk 非常類似。 有趣的是在獲得商業成功以前，還曾是知名搖滾樂團鼓手。\n以下是他幾個有趣的經歷:\n畢業於早稻田實業學校，在校時就成立重金屬樂團 Switch Style 擔任樂團鼓手。 他為了更真實地體驗日本體驗不到的音樂文化，還跑到美國街頭只為就近體驗。 回國後於 1993 發行首張 EP 即大賣，開始巡迴之旅。 自己喜歡蒐集唱片，從美國購買回來後意外發現有許多人也喜歡，只是有需求卻苦無門路，因此他開始嘗試從美國代購唱片，做起代購生意，做得有聲有色。 自己喜歡潮服，思考會不會喜歡那些唱片的人也喜歡這些潮服，想不到又大賣了。 自學編程架設電商，1998 年創立 線上時尚零售店 Start Today。 於 2004 年，將整合多家小型通路合併為 ZOZOTOWN。 dearMoon 計畫，2018 包下 SpaceX 大型獵鷹火箭，徵求 6-8 位藝術家在 2023 年一同環繞月球。 可惜於 2024 取消，因為 SpaceX Starship 星艦研發推延無法在預定時間 2023 年完成任務。 但在 2021 年，在俄羅斯的幫助下，自費登上了國際太空站，已完成他的太空夢。 我喜歡他的叛逆，喜歡他與眾不同，特立獨行。喜歡他說幹就幹，Start Today 的精神。\n他喜歡分享，喜歡開箱自己的新玩具，喜歡藝術、名車、名錶、私人飛機。 他不喜歡無聊，不願當朝九晚五的上班族，鼓勵大家少點工作，多點興趣。 他說錢是越花多的，有錢就花，會花才會賺。 而我最想學習的是他 Start Today 的精神。Let\u0026rsquo;s Start Something Today!\n","permalink":"https://wsmao.github.io/post/starttoday/","tags":null,"title":"前澤友作 — 不走平凡路"},{"categories":null,"contents":"用一個旁觀者的角度，主動去意識自己的行為，進而了解自己，探索自己。\n愛寫的我 我很愛寫，因為寫的時候就是我思考的時候。當我整理我的思緒，搞懂一些事情的時候，那種自我提升、進步的感覺是非常愉悅的。\n當有一堆想法的時候，我喜歡寫出來，當我寫出來我才發現這是零碎且混亂的。 我的大腦是如此有趣，一次只能想一件事情，但下一刻想的事情卻可能是此時此刻想也想不到的。 此時我可以利用筆記，它就像是我擴充的記憶體，我可以把所有想法載入，這樣我就可以同時看到這些想法。 更有趣的是，這時我就可以用第三者的視角來看自己腦中的想法。 我可以看到這些想法或許很有趣，或許是亂的無組織的，也可能根本是錯誤的。 然後我就可以跟自己對話，問自己問題，重新去組織，調整這些想法，產生新的想法。\n這種作法也適用於學習，當學習之後，我也喜歡寫出我的心得。 這過程中，我得思考要怎麼寫出來，故得先理一理我的思緒，伴隨修改的過程中，逐漸理出比較清晰的概念。\n由上述得出的結論是:寫作就是思考的一種方式。 之前寫過的 這篇文章 也有提到，\u0026ldquo;學、思、做\u0026quot;是一個正循環，且同等重要。 那喜歡閱讀(學)，寫作(思)以及動手創作(做)的我，不就正好符合這個循環嘛!\n關於我 我喜歡運動: 籃球，健身，單車，羽球。 我會一些樂器: 小提琴、鋼琴、吉他。 我喜歡烹飪，中式、日式、西式。 我平常不愛喝酒，只在對的氣氛跟對的人喝。 我本身是讀機械系，工作卻是韌體工程師，平時也會玩一些電子硬體設計。 容易分心的我 曾經在做專案A 的時候跑去做專案B，然後專案C，專案D。每一樣都做得有點樣子，但都沒有做完。\n分心的原因有很多\n我真的興趣太廣泛，什麼都想試試。 當專案做得太久，就無聊了，失去注意力。 當專案遇到困難，就逃避了，轉移注意力。 不懂拒絕，讓過多的外務干擾我。 我知道沒做完 = 沒做，這是我得克服的缺點。我相信意識到就可以想辦法克服。 所以我會繼續一一把專案做完，並且學習專注。\n有毅力的我 我可以每天早上 6 點到健身房報到。 曾經每天 2 點睡，5點起床到實驗室，後來捐血時被驗出爆肝。 其實蠻懷念那時的自己，有一個非幹不可的理由，充滿激情與抱負。 叛逆的我 以傳統的眼光來看，我是有點叛逆，畢竟我不會對父母師長的話百依百順。\n我有一點叛逆，不喜歡聽話。 我喜歡自己思考，自己得到解答，自己做決定。 當有人告訴我這樣不行，而我不理解，那我就會試試看，看看到底行與不行。 我喜歡走自己的路，不喜歡走大家走的路。 與其說是叛逆，不如說是獨立思考吧。\n其實沒有誰說得準，只有結果可以說話。因為沒有人能回到過去，重新走另一條路來實驗到底哪一條路更好，所以人生的選擇大多數沒有答案。既然選擇了，只需要盡力去做即可，不管結果覺得好壞，都要相信一切都已是最好的安排。\n隨興所欲的我 今天要幹嘛今天再決定，說白了是沒有意識的過生活。\n我不是很喜歡這樣的自己，所以一直嘗試管理自己，進行規劃，給予自己目標，試圖讓自己在軌道上前進。\n我也不曉得對或不對，還得對我自己多多實驗，找出適合我的方式。\n成長型思維的我 一直以來我都認為沒有我做不到的事情，只要花時間去嘗試，所有事情我都可以學會。\n這種心態固然很好，然而最近我也了解到，有些事情是我做得到，但是再努力都沒辦法做得比某些人好，這個叫作天賦。有時選擇是比努力更重要的，發揮自己的天賦，或許比努力彌補自己的短處來的有幫助。\n","permalink":"https://wsmao.github.io/post/%E8%AA%8D%E8%AD%98%E8%87%AA%E5%B7%B1/","tags":null,"title":"認識自己"},{"categories":null,"contents":"稚暉君曾在直播影片分享他的學習方式，其中邊打仗邊學習這句話讓我印象深刻。\n邊打仗邊學習強調了\u0026quot;做\u0026quot;的重要性，因為\u0026quot;只有做對了，才是學會了\u0026quot;。\n學習忌諱只學而不做，只有邊打仗邊學習才學得快。\n學習跟做缺一不可，兩者是相輔相成的正向循環。\n若只學而不做，那根本無法驗證你是否學會。 若只做而不學，那錯了不修正則一樣有學好。 好奇心是一種學習的欲望，想進步必須保持好奇心去探索，去學習。 而欲學好一件事，唯有做中學，學中做，\u0026quot;讓結果做你的導師\u0026quot;。\n這讓我想到另一句話: 學而不思則罔，思而不學則殆，這是孔子對學習態度的看法。\n「罔」，受欺，或解作迷惘。只知讀書，卻不肯思考，就會容易受欺蒙。 「殆」，疑惑，或解作危險。只顧思考，卻不去讀書，就容易想不通，引起疑惑。 「學」與「思」也必須相輔相成的正循環。 總結來說，學習的最佳方式是保持好奇心，在“學、思、做”三者之間找到平衡，並透過結果不斷迭代。\n","permalink":"https://wsmao.github.io/quote/%E7%A8%9A%E6%9A%89%E5%90%9B---%E9%82%8A%E6%89%93%E4%BB%97%E9%82%8A%E5%AD%B8%E7%BF%92/","tags":["quote"],"title":"最好的學習方式是: 邊打仗邊學習"},{"categories":null,"contents":"人的一輩子不過 3 萬多個日子，應當把握每個當下。\n我們要 \u0026mdash; 活得漂亮，熱情地追夢，並無所保留的去愛。\n","permalink":"https://wsmao.github.io/quote/unknown---live_beautifully/","tags":["quote"],"title":"Live beautifully, Dream Passionately, Love Completely."},{"categories":null,"contents":"當你撐不下去時怎麼辦？ 體操奧運冠軍媽媽的智慧提醒了我們，人總會在遇到困難時想著放棄，但是你也會在成功的時候慶幸當初自己沒有放棄。\n所以說，若你真的想放棄，那就在至少成功一次之後再做決定。\n倘若你真的不喜歡，那大可離開; 倘若你此時不願放棄了，那只說明過去想放棄的你，只是累了，此時的你將無比慶幸當初堅持下來的自己。\n","permalink":"https://wsmao.github.io/quote/nastia_liukin---you_can_quit_but_not_today/","tags":["quote"],"title":"You can quit, but not today."},{"categories":null,"contents":"緣起 寫 blog 紀錄並分享所學這個種子已經埋在心裡許久，其實也做過許多嘗試，然而最終都因為我搞錯這件事的\u0026quot;第一性原理\u0026quot;而放棄。\n某天在火車上划手機，看到了 Hahow 的這堂課 古君葳 - Github 免費架站術！輕鬆打造個人品牌 ，我看完介紹，二話不說就立刻購買開始上課。\n這不正是我需要的嗎? 既簡單又彈性。\n夠簡單，不用學習一堆網頁技術就能產出自己的網頁，光是這點就值得我投入 (因為重點是開始寫以及開始分享呀!) 用 Markdown、Github 以及 Git 任何人使用任何工具都可以馬上開始撰寫內容。 夠工程師，夠快速，純文字就能產生有點樣子的網頁。 Markdown 搭配 Git，可說是完全掌控了自己的 source 原始檔案，無須被 CMS 平台綁架，備份、版本控管甚至遷移都超級方便。 Github 還提供完全免費的架站空間阿，完美。 夠彈性，因此我認為 HUGO 適合絕大多數工程師(當然也不局限工程師): 只是想寫部落格的人，只需要套用別人的版型，簡單學一下 Markdown 語法，知道怎麼把內容上傳到 Github 平台即可。 一般工程師，尤其是軟體工程師，除了可以架設個人網站，還是用 Git、Markdown 等軟體工程師必用工具來架設的，超級簡單又方便，最適合不過了。 如果走前後端網頁領域的工程師(或者不滿意別人的版型)，也可以透過 HTML/CSS/Javascript 等技術，進一步客製化修改自己想要的版型(我就是喜歡自己設計)。 如果是對網站產生工具有興趣的話，HUGO 也是開源的工具哦，可以學習 GO 語言，去探究如此快速生成網頁的架構是如何設計的! 很開心現在透過網路課程學習課程是如此的方便。也特別感謝古古老師 開的這門課程，非常推薦大家去看看。內容不深且手把手教學，很好的介紹並帶領大家體驗 HUGO 這個架站神器。\n用 HUGO 架的網站，寫 HUGO 系列文章 既然使用了 HUGO 架站，也覺得蠻好用的，那就想要跟大家分享囉，有點 Meta-Hugo 的味道。\n本系列文章分為以下章節:\n初階概念篇，是寫給想要有自己的 blog，想立即寫文章分享的人。 進階概念篇，主要是寫給想自己動手客製化自己網站版型的人，這類的使用者需要有一點網頁前端技術的概念。 巨人的肩膀篇，如果除了有文章內容產出、好看的排版之後還想要更多進階功能，那就來試試超棒的第三方服務，站在巨人肩膀上吧。 初階概念篇 Hugo 架站，立刻發表文章: 從安裝，撰寫第一篇文章，到發布內容。 下載 Hugo 選主題 用 Markdown 寫文章 本機測試 上傳到 Github，遠端測試 Hugo 核心概念，檔案在幹嘛: 架構，目錄階層 Markdown config file、front matter 文章分類 HUGO 的 2 種 page 頁面，list \u0026amp; single 進階概念篇 Hugo 的 layout 系統: Hugo 如何找到適合的 template 來渲染內容 Hugo template 語法: 如何動態產生網頁內容。 Functions \u0026amp; Methods API: 好用的工具讓你事半功倍。 Hugo variables: 使用者資料如何儲存，Hugo 如何跟這些資料建立連結，最後在 Hugo template 中使用資料。 過去我犯的錯誤 那就是沒搞懂第一性原理。\n過去的我，搞錯重點了，我誤把\u0026quot;架設網站\u0026quot;當作重點，我想架設一個超級多功能、超級美的網站，顯然這不是我的初衷，只是完美主義的心態在作祟罷了。 搞錯重點的我學習許多前後端技術，並天真的打算從 0 到 1 雕刻出 blog，才要開始寫 blog。這導致我花了許多時間學了許多技術，但最終 blog 沒寫到就半途而廢了。 原因很簡單，因為我搞錯重點了，大量學習枯燥的技術，卻沒有一點有意義的產出，果不其然我失去動力了，我在做出 blog 前放棄寫 blog 了。\n原來，分享才是我想寫 blog 的第一性原理，我想分享，想幫助到別人，才是對我來說最重要的事情。至於是透過什麼媒介，哪怕在陽春的 blog，都不是重點。 開始分享就對了，分享就是利他主義，利人利己，何樂不為。希望我的學習經驗分享可以幫到人，即使只有一點點也很好。所謂教學相長，幫助到別人的同時也會回饋給自己。\n","permalink":"https://wsmao.github.io/hugo/about-hugo-series/","tags":["HUGO"],"title":"About hugo series."},{"categories":null,"contents":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea\nH1 H2 H3 H4 H5 H6 內文\n6 — Learn Version Control (GIT) 1 — The Fundamentals Back in the day, many developers would use USB drives to share their code. I did it too. This was like passing notes around, but it often led to confusion and mistakes, like losing important work or mixing up versions. Then came GIT, a game-changer that made sharing and managing code much easier. Instead of using USBs, developers could now track every change, work together without messing up each other’s work, and even go back to older versions if they needed to fix something. It was like moving from mailing letters to instant messaging, making coding together smoother and safer.\nSteps First, Second, Third, 1 - 這是 H1 標題 過去，許多開發人員會使用 USB 隨身碟來分享他們的程式碼。我也這麼做了。這就像到處傳遞筆記一樣，但它經常會導致混亂和錯誤，例如丟失重要的工作或混淆版本。隨後出現了 GIT，它是一個遊戲規則的改變者，它使共享和管理程式碼變得更加容易。現在，開發人員不再使用 USB，而是可以追蹤每個更改，在不干擾彼此工作的情況下協同工作，甚至在需要修復某些問題時返回舊版本。這就像從郵寄信件轉向即時訊息一樣，使一起編碼變得更加順暢和安全。\n2 - 這是 order list 測試 第一點 Then came GIT 第二點 第三點 3 - 這是 quote 測試 過去，許多開發人員會使用 USB 隨身碟來分享他們的程式碼。我也這麼做了。這就像到處傳遞筆記一樣，但它經常會導致混亂和錯誤，例如丟失重要的工作或混淆版本。隨後出現了 GIT，它是一個遊戲規則的改變者，它使共享和管理程式碼變得更加容易。現在，開發人員不再使用 USB，而是可以追蹤每個更改，在不干擾彼此工作的情況下協同工作，甚至在需要修復某些問題時返回舊版本。這就像從郵寄信件轉向即時訊息一樣，使一起編碼變得更加順暢和安全。\n#include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; int main(void){ return 0; } 4 - 其他 style 測試 This is bold style.\nThis is Italic style.\nNo =highlight= style.\nNo ==highlight== style.\nThis is strike\nThis is embedded style.\n使用指令 git add 去加入 index。\n5 - Code syntax highlighting test #include \u0026#34;stdio.h\u0026#34; #include \u0026#34;stdlib.h\u0026#34; int num = 10; int foo(int a){ return a; } int main(void){ printf(\u0026#34;hello world %d\\n\u0026#34;, num); int val = foo(num); return 0; } Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLink I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nList List item List item List item List item List item Unordered List List item List item List item List item List item Code and Syntax Highlighting Inline code has back-ticks around it.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s No language indicated, so no syntax highlighting. But let\u0026#39;s throw in a \u0026lt;b\u0026gt;tag\u0026lt;/b\u0026gt;. Blockquote This is a blockquote example.\nInline HTML You can also use raw HTML in your Markdown, and it\u0026rsquo;ll mostly work pretty well.\nTables Colons can be used to align columns.\nTables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don\u0026rsquo;t need to make the raw Markdown line up prettily. You can also use inline Markdown.\nMarkdown Less Pretty Still renders nicely 1 2 3 Image Youtube video ","permalink":"https://wsmao.github.io/test/test/","tags":null,"title":"This is test file"}]
