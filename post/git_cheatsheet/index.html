<!DOCTYPE html>
<html lang="zh-tw"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8">
  <title>Code My Life</title>

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="This is Chris&#39;s Blog. Welcome!">
  <meta name="author" content="Chris">
    
  
  <meta name="theme-name" content="Digital-Zen" />
  
  <meta name="generator" content="Hugo 0.139.0">

  <!-- plugins -->
  
  <link rel="stylesheet" href="http://localhost:1313/plugins/bootstrap/bootstrap.min.css ">
  
  <link rel="stylesheet" href="http://localhost:1313/plugins/themify-icons/themify-icons.css ">
  

  <!-- Main Stylesheet -->
  
  <link rel="stylesheet" href="http://localhost:1313/scss/style.min.css" media="screen">

  <!--Favicon-->
  <link rel="shortcut icon" href="http://localhost:1313/images/00-site/favicon.png " type="image/x-icon" sizes="32x32">
  <link rel="icon" href="http://localhost:1313/images/00-site/favicon.png " type="image/png" sizes="32x32">

  <!-- google fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Italianno&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC&family=Noto+Sans+TC:wght@100..900&display=swap" rel="stylesheet">

  <!-- highlightjs -->
  



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/night-owl.css">
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>


<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/c.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/cpp.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/python.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/javascript.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/css.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/http.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/markdown.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/json.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/ini.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/shell.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/excel.min.js"></script>

<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/languages/plaintext.min.js"></script>


<!-- copy button -->
<link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css">
<script defer src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js" onload="hljs.addPlugin(new CopyButtonPlugin());"></script>

<!-- highlight all pre code element -->
<script defer>
document.addEventListener('DOMContentLoaded', (event) => {
  document.querySelectorAll('pre code').forEach((el) => {
    hljs.highlightElement(el);
  });
});
</script>


  <!-- google analitycs -->
  <script>
    (function (i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function () {
        (i[r].q = i[r].q || []).push(arguments)
      }, i[r].l = 1 * new Date();
      a = s.createElement(o),
        m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');
    ga('create', 'Your ID', 'auto');
    ga('send', 'pageview');
  </script>

</head>
<body>
        
<!-- preloader start -->
<div class="preloader">
  
</div>
<!-- preloader end -->
<!-- navigation -->
<header class="navigation">
  <div class="container">
    
    <nav class="navbar navbar-expand-lg navbar-white bg-transparent border-bottom pl-0">
      <a class="navbar-brand mobile-view" href="http://localhost:1313/"><img class="img-fluid"
          src="http://localhost:1313/images/00-site/logo.svg" alt="Code My Life"></a>
      <button class="navbar-toggler border-0" type="button" data-toggle="collapse" data-target="#navigation">
        <i class="ti-menu"></i>
      </button>

      <div class="collapse navbar-collapse text-center" id="navigation">
        
        
        
        <ul class="navbar-nav">
          
          
          <li class="nav-item">
            <a class="nav-link" href="http://localhost:1313/post/">Post</a>
          </li>
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="http://localhost:1313/hugo/">Hugo</a>
          </li>
          
          
        </ul>
        
        
        <a class="navbar-brand mx-auto desktop-view" href="http://localhost:1313/"><img class="img-fluid"
            src="http://localhost:1313/images/00-site/logo.svg" alt="Code My Life"></a>
        
        
        <ul class="navbar-nav">
          
          
          <li class="nav-item">
            <a class="nav-link" href="http://localhost:1313/tags/">Tags</a>
          </li>
          
          
        </ul>

        
        <!-- search -->
        <div class="search pl-lg-4">
          <button id="searchOpen" class="search-btn"><i class="ti-search"></i></button>
          <div class="search-wrapper">
            <form action="http://localhost:1313//search" class="h-100">
              <input class="search-box px-4" id="search-query" name="s" type="search" placeholder="Type & Hit Enter...">
            </form>
            <button id="searchClose" class="search-close"><i class="ti-close text-dark"></i></button>
          </div>
        </div>
        

        
      </div>
    </nav>
  </div>
</header>
<!-- /navigation -->



<section class="section-sm">
  <div class="container">
    <div class="row">
      <div class="col-lg-12 mx-auto">
        
        <h1>Git Cheatsheet.</h1>
        <div class="mb-3 post-meta">
          <span>By Chris</span>
          
          <span class="border-bottom border-primary px-2 mx-1"></span>
          <span>18 February 2025</span>
          
        </div>
        
        <div class="content mb-5">
          <h1 id="基本指令索引">基本指令索引</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><a href="#%E6%89%93%E5%8C%85%E8%AE%8A%E6%9B%B4%E8%88%87%E6%8F%90%E4%BA%A4%E7%B4%80%E9%8C%84"><code>git add &lt;file&gt;</code></a></td>
          <td>打包檔案變更</td>
      </tr>
      <tr>
          <td><a href="#%E5%88%86%E6%94%AF"><code>git branch</code></a></td>
          <td>顯示本地分支列表</td>
      </tr>
      <tr>
          <td><a href="#%E6%89%93%E5%8C%85%E8%AE%8A%E6%9B%B4%E8%88%87%E6%8F%90%E4%BA%A4%E7%B4%80%E9%8C%84"><code>git commit -m &quot;message&quot;</code></a></td>
          <td>提交改變，製作 commmit</td>
      </tr>
      <tr>
          <td><a href="#%E5%88%87%E6%8F%9B%E7%89%88%E6%9C%AC"><code>git checkout &lt;commit-SHA&gt;</code></a></td>
          <td>提取某個 commit 版本 worktree</td>
      </tr>
      <tr>
          <td><a href="#%E5%88%86%E6%94%AF"><code>git checkout -b &lt;branch&gt;</code></a></td>
          <td>新增 branch</td>
      </tr>
      <tr>
          <td><a href="#%E9%81%A0%E7%AB%AF%E5%8D%94%E4%BD%9C"><code>git clone &lt;url&gt;</code></a></td>
          <td>複製 remote repo 至 local</td>
      </tr>
      <tr>
          <td><a href="#%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A"><code>git config</code></a></td>
          <td>進行.git 工具設定</td>
      </tr>
      <tr>
          <td><a href="#%E5%B7%AE%E7%95%B0%E6%AF%94%E8%BC%83"><code>git diff &lt;commit1&gt; &lt;commit2&gt;</code></a></td>
          <td>比較版本差異</td>
      </tr>
      <tr>
          <td><a href="#%E9%81%A0%E7%AB%AF%E5%8D%94%E4%BD%9C"><code>git fetch</code></a></td>
          <td>取得遠端最新變更但不合併</td>
      </tr>
      <tr>
          <td><a href="#%E5%88%86%E6%94%AF"><code>git fetch --prune</code></a></td>
          <td>清除已刪除的遠端分支</td>
      </tr>
      <tr>
          <td><code>git init</code></td>
          <td>git 環境初始化</td>
      </tr>
      <tr>
          <td><a href="#%E6%AA%94%E6%A1%88%E8%BF%BD%E8%B9%A4"><code>git ls-files</code></a></td>
          <td>列出所有追蹤中的檔案</td>
      </tr>
      <tr>
          <td><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%B7%E5%8F%B2"><code>git log</code></a></td>
          <td>查看 commit log, file log</td>
      </tr>
      <tr>
          <td><a href="#%E5%90%88%E4%BD%B5"><code>git merge &lt;commit-SHA&gt;</code></a></td>
          <td>將指定 commit 合併至 HEAD</td>
      </tr>
      <tr>
          <td><a href="#%E9%81%A0%E7%AB%AF%E5%8D%94%E4%BD%9C"><code>git push</code></a></td>
          <td>推送變更到遠端分支</td>
      </tr>
      <tr>
          <td><a href="#%E9%81%A0%E7%AB%AF%E5%8D%94%E4%BD%9C"><code>git pull</code></a></td>
          <td>拉取遠端分支並合併</td>
      </tr>
      <tr>
          <td><a href="#%E9%81%A0%E7%AB%AF%E5%8D%94%E4%BD%9C"><code>git remote</code></a></td>
          <td>查看 remote 設定</td>
      </tr>
      <tr>
          <td><a href="#%E6%94%B9%E8%AE%8A%E6%AD%B7%E5%8F%B2"><code>git reset</code></a></td>
          <td>讓分支回到某個 commit</td>
      </tr>
      <tr>
          <td><a href="#%E5%90%88%E4%BD%B5"><code>git rebase &lt;commit-SHA&gt;</code></a></td>
          <td>重新整理當前分支並套用變更</td>
      </tr>
      <tr>
          <td><a href="#%E6%9F%A5%E7%9C%8B%E6%AD%B7%E5%8F%B2"><code>git reflog</code></a></td>
          <td>查看 HEAD 的變更歷史</td>
      </tr>
      <tr>
          <td><a href="#%E5%8F%96%E6%B6%88%E6%9B%B4%E5%8B%95"><code>git restore</code></a></td>
          <td>恢復 stage area 或者 worktree 的變更</td>
      </tr>
      <tr>
          <td><a href="#%E6%AA%94%E6%A1%88%E8%BF%BD%E8%B9%A4"><code>git rm --cached &lt;file&gt;</code></a></td>
          <td>讓 Git 保留檔案但停止追蹤</td>
      </tr>
      <tr>
          <td><a href="#%E7%8B%80%E6%85%8B"><code>git status</code></a></td>
          <td>查看目前 Git 的狀態</td>
      </tr>
      <tr>
          <td><code>git show &lt;commit&gt;</code></td>
          <td>可以看基本資訊，以及檔案差異</td>
      </tr>
      <tr>
          <td><a href="#%E6%9A%AB%E5%AD%98%E8%AE%8A%E6%9B%B4"><code>git stash</code></a></td>
          <td>暫存當前變更</td>
      </tr>
      <tr>
          <td><a href="#%E6%A8%99%E7%B1%A4"><code>git tag &lt;tag_name&gt;</code></a></td>
          <td>在當前 commit 打 tag 標籤</td>
      </tr>
  </tbody>
</table>
<h1 id="進階指令索引">進階指令索引</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git revert HEAD</code></td>
          <td>新增反向 commit，用於取消最新的 commit，但保留取消歷史</td>
      </tr>
      <tr>
          <td><code>git cat-file -p &lt;commit-SHA&gt;</code></td>
          <td>還原 Git 物件的內容</td>
      </tr>
      <tr>
          <td><code>git cat-file -t &lt;commit-SHA&gt;</code></td>
          <td>查看物件類型</td>
      </tr>
      <tr>
          <td><code>git ls-files -s</code></td>
          <td>列出當前目錄下包含子目錄底下的 blobs</td>
      </tr>
      <tr>
          <td><code>git clone --recurse-submodules &lt;URL&gt;</code></td>
          <td>一併下載相依的 submodules</td>
      </tr>
      <tr>
          <td><code>git cherry-pick</code></td>
          <td>可以從 commit tree 的任何地方拿一個 commit 來放在 HEAD 上（只要那個 commit 不是 HEAD 的 parent）</td>
      </tr>
      <tr>
          <td><a href="#%E5%90%88%E4%BD%B5"><code>git rebase -i &lt;commit-SHA&gt;</code></a></td>
          <td>互動式 rebase，若 rebase 之中有許多 commits 要剪下貼上，可以選擇只 rebase 那些 commits，甚至可以排序</td>
      </tr>
  </tbody>
</table>
<h1 id="觀念">觀念</h1>
<ul>
<li><a href="#git-%E5%9B%9B%E5%A4%A7%E7%89%A9%E4%BB%B6">Git 四大物件</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D">快速定位</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%A9%9E%E5%8F%8A%E6%A6%82%E5%BF%B5">基本名詞及概念</a></li>
</ul>
<h1 id="主題">主題</h1>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%A8%AD%E5%AE%9A">基本設定</a></li>
<li><a href="#%E5%88%9D%E6%AC%A1%E9%80%A3%E6%8E%A5-remote-repo">連接 remote</a></li>
</ul>
<h1 id="狀態">狀態</h1>
<p>檔案變動狀態</p>
<ul>
<li>M: Modify</li>
<li>A: Add to staging area</li>
<li>D: Deleted</li>
<li>U: Untracted files in worktree.</li>
</ul>
<h1 id="檔案追蹤">檔案追蹤</h1>
<ul>
<li><code>git ls-files</code> 列出所有追蹤中的檔案。</li>
<li><code>git rm --cached &lt;file&gt;</code> 讓 Git 停止追蹤檔案。</li>
<li><code>.gitignore</code> 用來設定 Git 忽略檔案的規則，其中列出的檔案 Git 會予以忽略，不會追蹤其改變。
<ul>
<li>但已經在追蹤的檔案，不受 <code>.gitignore</code> 檔案影響，必須先停止追蹤 (<code>git rm --cached &lt;file&gt;</code>)，再加入 <code>.gitignore</code>，之後該檔案的變動才不會被追蹤。</li>
</ul>
</li>
</ul>
<h1 id="打包變更與提交紀錄">打包變更與提交紀錄</h1>
<h2 id="打包">打包</h2>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git add .</code></td>
          <td>打包所有檔案變更。</td>
      </tr>
      <tr>
          <td><code>git add filename</code></td>
          <td>打包指定檔案變更。</td>
      </tr>
      <tr>
          <td><code>git add -p filename</code></td>
          <td>選擇性地新增某檔案的部分變更。</td>
      </tr>
  </tbody>
</table>
<p>所謂打包就是將 worktree 變更(Changes)儲存至 staging area(Staged Changes)。用意是將需要提交的變更先整理起來，再發一個 commit 提交出去。
比如你可能會想要將較不相關的變動分次提交，所以你會先打包相關的一部分儲存至 staging area，進行 commit 提交時，只有 staging area 的變更會被提交出去。沒有被 staged 的部分還維持在 &ldquo;Changes&quot;的狀態。</p>
<h2 id="提交">提交</h2>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git commit -m &quot;message&quot;</code></td>
          <td>提交改變，製作 commit</td>
      </tr>
      <tr>
          <td><code>git commit --amend -m &quot;message&quot;</code></td>
          <td>拆掉最新的 commit 連同新提交到 staging area 的部分，重新製作 commit</td>
      </tr>
  </tbody>
</table>
<h1 id="取消更動">取消更動</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git restore -W .</code></td>
          <td>就會恢復 Worktree 所有修改(預設選項)</td>
      </tr>
      <tr>
          <td><code>git restore -S .</code></td>
          <td>就會恢復 Stage area 所有修改 (staged changes —&gt; changes)</td>
      </tr>
  </tbody>
</table>
<h1 id="切換版本">切換版本</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git checkout &lt;commit-SHA&gt;</code></td>
          <td>切換至指定 commit 版本</td>
      </tr>
      <tr>
          <td><code>git checkout &lt;commit&gt; &lt;file&gt;</code></td>
          <td>指定檔案回復到某個 commit 版本</td>
      </tr>
      <tr>
          <td><code>git checkout .</code></td>
          <td>切換至當前版本，相當於還原當前工作區所有修改，建議以 <code>git restore .</code> 指令取代</td>
      </tr>
  </tbody>
</table>
<p>checkout 切換至某個版本、提取某個版本資料，均會更新工作目錄。</p>
<ol>
<li>
<p>整個 worktree 切換至指定 commit 版本</p>
<ul>
<li><code>git checkout &lt;commit-SHA&gt;</code></li>
<li>必須是工作目錄目前沒有任何修改的檔案，否則給予警告不給切換，因為他要切換至其他版本了，將改變工作目錄，而目前的修改尚未保存。</li>
<li>切換後 HEAD 會指向該 commit。</li>
</ul>
</li>
<li>
<p>指切換單一檔案至特定 commit 之版本</p>
<ul>
<li><code>git checkout &lt;commit&gt; &lt;file&gt;</code></li>
<li>回復指定檔案到某個 commit 版本。只會更新 worktree 檔案內容，並不會動到 HEAD。</li>
</ul>
</li>
</ol>
<h1 id="分支">分支</h1>
<p>在本地 repo 的 branch 稱為 local branch; 在 remote repo 的 branch 稱為 remote branch;
而在本地 repo 用來追蹤 remote branch 的稱作 remote-tracking branch。</p>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git branch</code></td>
          <td>顯示本地分支列表。</td>
      </tr>
      <tr>
          <td><code>git branch -a</code></td>
          <td>顯示所有分支(包含遠端)</td>
      </tr>
      <tr>
          <td><code>git branch -vv</code></td>
          <td>顯示所有分支的詳細訊息，包含 upstream 對應</td>
      </tr>
      <tr>
          <td><code>git branch -d &lt;branch_name&gt;</code></td>
          <td>刪除本地分支</td>
      </tr>
      <tr>
          <td><code>git branch -rd &lt;remote&gt;/&lt;branch_name&gt;</code></td>
          <td>刪除追蹤分支 (-r 代表 remote)</td>
      </tr>
      <tr>
          <td><code>git branch &lt;branch_name&gt;</code></td>
          <td>新增 branch 於目前 HEAD 上</td>
      </tr>
      <tr>
          <td><code>git branch &lt;branch_name&gt; &lt;commit-SHA&gt;</code></td>
          <td>新增 branch 於指定 commit 上</td>
      </tr>
      <tr>
          <td><code>git branch -f &lt;branch_name&gt; &lt;commit-SHA&gt;</code></td>
          <td>強制將現有 branch 改貼到指定 commit 上，但不可以是 HEAD 正指向之 branch</td>
      </tr>
      <tr>
          <td><code>git checkout -b &lt;branch_name&gt;</code></td>
          <td>新增 branch 於目前 HEAD 上並切換到該分支</td>
      </tr>
      <tr>
          <td><code>git checkout &lt;commit-SHA&gt; -b &lt;branch_name&gt;</code></td>
          <td>新增 branch 於指定 commit 上並切換到該分支</td>
      </tr>
  </tbody>
</table>
<p>其他相關:</p>
<ul>
<li><code>git fetch --prune</code> 若遠端已沒有該分支但本地端還有其追蹤分支的話，予以刪除。</li>
</ul>
<h1 id="標籤">標籤</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git tag &lt;tag_name&gt;</code></td>
          <td>新增 tag</td>
      </tr>
      <tr>
          <td><code>git tag &lt;tag_name&gt; &lt;commit&gt;</code></td>
          <td>新增 tag 於指定 commit 上</td>
      </tr>
      <tr>
          <td><code>git tag -d &lt;tag_name&gt;</code></td>
          <td>刪除 tag</td>
      </tr>
      <tr>
          <td><code>git tag &lt;tag_name&gt; -a -m &quot;message&quot;</code></td>
          <td>新增帶有註解（annotated）的 tag</td>
      </tr>
  </tbody>
</table>
<h1 id="查看歷史">查看歷史</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git log</code></td>
          <td>查看 commit 記錄 (預設為 HEAD 指向)</td>
      </tr>
      <tr>
          <td><code>git log --oneline</code></td>
          <td>單行簡潔查看 commit 記錄</td>
      </tr>
      <tr>
          <td><code>git log -- &lt;path/to/file&gt;</code></td>
          <td>只查看某個檔案的 commit 記錄</td>
      </tr>
      <tr>
          <td><code>git log -p</code></td>
          <td>-p 顯示變更內容</td>
      </tr>
      <tr>
          <td><code>git reflog</code></td>
          <td>查看 HEAD 的變更歷史</td>
      </tr>
  </tbody>
</table>
<h1 id="改變歷史">改變歷史</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git reset &lt;commit-SHA&gt;</code></td>
          <td>拆掉當前 commit，分支回到指定 commit(預設為 &ndash;mixed)</td>
      </tr>
      <tr>
          <td><code>git reset --soft &lt;commit-SHA&gt;</code></td>
          <td>拆掉當前 commit，分支回到指定 commit，拆除之變更保留在 staged 狀態</td>
      </tr>
      <tr>
          <td><code>git reset --mixed &lt;commit-SHA&gt;</code></td>
          <td>拆掉當前 commit，分支回到指定 commit，拆除之變更保留在 changes 狀態</td>
      </tr>
      <tr>
          <td><code>git reset --hard &lt;commit-SHA&gt;</code></td>
          <td>拆掉當前 commit，分支回到指定 commit，刪除所有變更</td>
      </tr>
  </tbody>
</table>
<p>想像 commit1 到 commit2 的過程: <strong>commit1 -&gt; changes -&gt; staged changes -&gt; commit2</strong></p>
<ul>
<li>&ndash;soft 就是回退 1 步到 staged changes 狀態</li>
<li>&ndash;mixed 就是回退 2 步到 changes 狀態</li>
<li>&ndash;hard 就是回退 3 步到 commit1 狀態</li>
</ul>
<h1 id="遠端協作">遠端協作</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git fetch &lt;remote&gt;</code></td>
          <td>取得遠端最新變更但不合併</td>
      </tr>
      <tr>
          <td><code>git pull &lt;remote&gt; &lt;branch&gt;</code></td>
          <td>拉取遠端分支並合併到 HEAD</td>
      </tr>
      <tr>
          <td><code>git pull --rebase</code></td>
          <td>表示要使用 rebase 的方式合併 fetch 下來的 commit</td>
      </tr>
      <tr>
          <td><code>git push</code></td>
          <td>推送當前分支到對應的 upstream 分支</td>
      </tr>
      <tr>
          <td><code>git push &lt;remote&gt; &lt;branch&gt;</code></td>
          <td>推送指定分支同步至遠端</td>
      </tr>
      <tr>
          <td><code>git push &lt;remote&gt; &lt;branch&gt; --force</code></td>
          <td>強制推送</td>
      </tr>
      <tr>
          <td><code>git push -u &lt;remote&gt; &lt;branch&gt;</code></td>
          <td>推送時一併設定 branch upstream</td>
      </tr>
      <tr>
          <td><code>git branch -vv</code></td>
          <td>可以使用此指令 查看 branch 是否設置 upstream</td>
      </tr>
      <tr>
          <td><code>git remote</code></td>
          <td>查看 remote repo</td>
      </tr>
      <tr>
          <td><code>git remote -v</code></td>
          <td>-v for verbos 提供更多訊息</td>
      </tr>
      <tr>
          <td><code>git remote add &lt;remote&gt; &lt;remote repository URL&gt;</code></td>
          <td>建立 remote repository 指標</td>
      </tr>
  </tbody>
</table>
<h2 id="upstream">upstream</h2>
<p>upstream 就是 &lt;local_branch&gt; 預設進行 push/pull/fetch 等指令的 &lt;remote_branch&gt; 分支。
設定好 upstream 使得進行 push/pull/fetch 等指令時，不用每次都詳細指定 &lt;local_branch&gt; 是要跟哪個 &lt;remote_branch&gt; 互動，會比較方便。
若設定 &lt;remote_branch&gt; 為 &lt;local_branch&gt; 之 upstream，當然也可以反過來說 &lt;local_branch&gt; 是 &lt;remote_branch&gt; 之 downstream。</p>
<h3 id="建立-upstream">建立 upstream</h3>
<p>當 remote 端已有該 branch 時，我們可以這樣建立 upstream。</p>
<ul>
<li>必須要先取得該 &lt;remote_branch&gt; 的追蹤分支，使用 <code>git fetch &lt;remote&gt; &lt;branch&gt;</code>。</li>
<li>為當前 HEAD 指向的 branch 設定 upstream，使用 <code>git branch -u &lt;remote&gt;/&lt;branch&gt;</code> 或 <code>git branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt;</code>。</li>
<li>也可以指定為哪個 branch 設定 upstream，<code>git branch -u &lt;remote&gt;/&lt;branch&gt; &lt;branch&gt;</code></li>
<li>或者建立參考於 &lt;remote_branch&gt; 的新分支 <code>git checkout &lt;remote&gt;/&lt;branch&gt; -b &lt;branch&gt;</code>，就會自動設立 upstream 關係。</li>
</ul>
<p>而若是遠端沒有該 branch，我們可以推送 &lt;local_branch&gt; 上去建立 &lt;remote_branch&gt; 同時建立 upstream 關係。
<code>git push -u &lt;remote&gt; &lt;local_branch&gt;:&lt;remote_branch&gt;</code> 或者 local 跟 remote 同名的話 <code>git push -u &lt;remote&gt; &lt;branch&gt;</code>。</p>
<h3 id="取消-upstream">取消 upstream</h3>
<p><code>git branch --unset-upstream</code></p>
<h3 id="查看-upstream">查看 upstream</h3>
<ul>
<li><code>git branch -vv</code> 可以看到所有 branch 的詳細訊息，包含該 branch 是否有 upstream branch。</li>
<li><code>git remote show &lt;remote&gt;</code> 會顯示 &lt;remote&gt; 的詳細訊息，包含 &lt;local_branch&gt; 對應到的 &lt;remote_branch&gt;，即 upstream。</li>
</ul>
<h2 id="git-clone">git clone</h2>
<ul>
<li>若是由 github clone 下來的 repo，預設只會得到 1 個 default branch 以及 1 個 指向該 github repo 的 remote(名為 origin)。
使用 <code>git branch -a</code> 可以看到其他 remote 分支，若你想要建立該 &lt;remote_branch&gt; 的 downstream 可以 <code>git branch &lt;branch&gt; &lt;remote_branch&gt;</code>。</li>
</ul>
<h2 id="git-push">git push</h2>
<p>一定要知道來源與目標，來源可以是 commit 但目標一定是 branch，目標不存在也沒關係，會自動創建。
push 前，須保證不會 conflict，所以會被檢查 remote_branch 的 history，local commit 是否都有，若沒有要先 fetch 更新，merge 後在 local 解決衝突才能重新 push。</p>
<p><code>git push &lt;remote&gt; &lt;commit&gt;:&lt;remote_branch&gt; </code></p>
<ul>
<li>即 push &lt;local_branch&gt; -&gt; &lt;remote_branch&gt;，意思是把 &lt;local_branch&gt; 上傳到 &lt;remote&gt; 然後合併到 &lt;remote_branch&gt;，如果 remote repo 沒有該 branch 則會在 remote 上自動創建一個。
<ul>
<li>可以看到本地跟遠端的分支名稱可以不同，雖然很少會需要這麼做。</li>
<li>甚至本地端可以直接指定 commit</li>
</ul>
</li>
</ul>
<p><code>git push &lt;remote&gt; &lt;branch&gt;</code></p>
<ul>
<li>同名，把同名 local <!-- raw HTML omitted --> 同步到 remote <!-- raw HTML omitted --></li>
</ul>
<p><code>git push</code></p>
<ul>
<li>都沒給參數代表可以推理出來，當前 HEAD 需指向設定好 upstream 的 branch，如此可推得 &lt;remote&gt; 以及 &lt;remote_branch&gt;。</li>
</ul>
<p>特別技: 如何在 local 端刪除 remote 端的分支? 就是讓 &lt;local_branch&gt; 的地方留空，<code>git push &lt;remote&gt;   :&lt;remote_branch&gt; </code>，push 一個空 branch 到 remote 代表刪除。</p>
<h2 id="git-fetch">git fetch</h2>
<p>主要是更新<strong>遠端分支</strong>的狀態(所以 tracking-branch 會改變)，若有需要會自動創建 remote-tracking branch。</p>
<p><code>git fetch</code></p>
<ul>
<li>更新<strong>所有</strong> remote_branch 的狀態。
<code>git fetch &lt;remote&gt; &lt;branch&gt;</code></li>
<li>更新<strong>指定</strong> remote_branch 的狀態。
<code>git fetch &lt;remote&gt; &lt;src&gt;:&lt;dst&gt;</code></li>
<li><strong>我個人認為不要使用，因為他讓 fetch 不再只是單純更新 tracking-branches 的動作，還包含快速移動分支等 merge 概念，概念被複雜化了。</strong></li>
<li>可指定更新給誰，可以是 local branch 或 tracking branch 或 HEAD</li>
<li>dst 不可是當前 checkout 的分支</li>
<li>若 src 是 branch 則會更新 tracking branch 也會將新的 commit 增加到 dst 上。</li>
<li>若 src 是 commit 則不會更新 tracking branch，只會將新的 commit 增加到 dst 上。</li>
</ul>
<h2 id="git-pull">git pull</h2>
<p><strong>git pull = git fetch + git merge</strong>，也就是 fetch 遠端分支的更新，並嘗試 merge。</p>
<p>記得 merge 是針對 HEAD 位置的操作。</p>
<p><code>git pull &lt;remote&gt; &lt;remote_commit&gt;:&lt;local_branch&gt;</code> = <code>git fetch &lt;remote&gt; &lt;remote_commit&gt;:&lt;local_branch&gt;</code> + <code>git merge &lt;local_branch&gt;</code></p>
<ul>
<li><strong>我個人認為不要使用</strong>，因為指令結果複雜不好記憶，fetch 指令在這樣的格式下不只是 fetch remote 狀態，還會移動 local_branch，然而 pull 又包含 merge 又會移動 HEAD 位置。總之若非很熟悉，太複雜的指令沒必要用，可以用多個基礎指令一步步完成就好，好記又不容易錯。</li>
<li>得以指定 fetch source 以及 merge target</li>
<li>由 HEAD 指向的 branch 去 merge 收到 fetch 的 &lt;local_branch&gt;</li>
</ul>
<p>git pull origin bar:bugFix 相當於：</p>
<pre tabindex="0"><code>git fetch origin bar:bugFix; 
git merge bugFix
</code></pre><p><code>git pull &lt;remote&gt; &lt;branch&gt;</code> = <code>git fetch &lt;remote&gt; &lt;branch&gt;</code> + <code>git merge &lt;branch&gt;</code></p>
<p>git pull origin foo 相當於：</p>
<pre tabindex="0"><code>git fetch origin foo; 
git merge origin/foo
</code></pre><p><code>git pull</code>  = <code>git fetch &lt;remote&gt; &lt;branch&gt;</code> + <code>git merge &lt;remote_branch&gt;</code></p>
<ul>
<li>git pull 沒有參數，故由 HEAD 指向之 branch 推論，該 branch 需要設定好 upstream，固可推得哪個 &lt;remote&gt; 以及哪個 &lt;remote_branch&gt;。</li>
<li>可以看到使用 <code>git fetch &lt;remote&gt; &lt;branch&gt;</code> 只會取得 upstream 更新，並不是 <code>git fetch</code> 取得所有更新。</li>
</ul>
<p>git pull 相當於:</p>
<pre tabindex="0"><code>git fetch &lt;remote&gt; &lt;upstream&gt;
git merge &lt;upstream&gt;
</code></pre><h1 id="合併">合併</h1>
<h2 id="merge">Merge</h2>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git merge &lt;commit-SHA&gt;</code></td>
          <td>當前分支嘗試合併某 commit 內容 (fast forward 優先)</td>
      </tr>
      <tr>
          <td><code>git merge &lt;commit-SHA&gt; --no-ff</code> -m &ldquo;merge message&rdquo;</td>
          <td>使用 &ndash;no-ff 禁用 fast forward，必會產生 merge 訊息</td>
      </tr>
      <tr>
          <td><code>git merge --squash &lt;commit-SHA&gt;</code></td>
          <td>???</td>
      </tr>
      <tr>
          <td><code>git merge --abort</code></td>
          <td>當 merge conflict 時，若想放棄這次 merge 回復 merge 前狀態時使用</td>
      </tr>
  </tbody>
</table>
<p>git merge <strong>一定是對 HEAD 位置 merge</strong>，HEAD 不一定要指向 branch(但通常是)，merge 完 HEAD 會移動，若HEAD 指向 branch 則 branch 也會移動。</p>
<p>Fast Forward（快速前進）是一種 合併（merge）策略，當 當前分支的 HEAD 沒有與目標分支產生分歧，而目標分支只是在 HEAD 之後新增了 commit 時，Git 會直接把 HEAD 指向最新的 commit，而不產生新的 merge commit。</p>
<p>Fast Forward 合併的條件：只要 commits 鍊是可以溯源，那必定可以 Fast Forward。
比如當前分支 A 是目標分支 B 的祖先之一，那從 B commits 溯源並訂可以找到 A commits，則必可以 Fast Forward。</p>
<ul>
<li>No Fast-Forward 的 merge，必定會額外產生出一個 commit 紀錄是由哪兩個 commit 合併的，故會看到 2 個 parents。當你想要特意保留 merge 訊息可使用。</li>
<li>Fast-Forward merge 則不會有 merge commit，僅是將當前分支直接快轉移動貼到另一個 commit 上，故會看不出來曾經有與其他 branch 合併過。</li>
</ul>
<h3 id="merge-conflict">Merge Conflict</h3>
<p>當兩分枝執行合併，但兩個分支都修改了一樣的內容，導致讓 git 不知怎麼合併，這就是 merge conflict。
此時，merge 會被暫停並且 git 會把衝突的檔案以及兩分枝的差異標示給你看，讓你自行選擇怎麼修正。
不管你怎麼修正，修完之後再次 <code>git add</code>、<code>git commit</code> 提交，就算是解決 conflict 了。</p>
<h2 id="rebase">Rebase</h2>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git rebase &lt;commit-SHA&gt;</code></td>
          <td>把自己跟別人不同的 commit 都剪下重新長在別人身上。</td>
      </tr>
      <tr>
          <td><code>git rebase --continue</code></td>
          <td>當 rebase 遇到 conflict 時，待解決後以此指令繼續 rebase 過程。</td>
      </tr>
      <tr>
          <td><code>git rebase &lt;on-commit&gt; &lt;from-commit&gt;</code></td>
          <td>比對 commits 差異，將 <!-- raw HTML omitted --> 不同的 commits 剪下貼在 <!-- raw HTML omitted --> 上</td>
      </tr>
      <tr>
          <td><code>git rebase -i &lt;commit-SHA&gt;</code></td>
          <td>互動式 rebase，自由決定要剪下哪些 commits，還可以調整順序，按照指定順序重新長在指定之 commit 上!</td>
      </tr>
      <tr>
          <td><code>git pull --rebase</code></td>
          <td>使用 rebase 的方式處理 fetch 到的 commit</td>
      </tr>
  </tbody>
</table>
<p>Rebase 與 merge 之差別:</p>
<ul>
<li>不會另外做出 merge 物件。</li>
<li>有點像將 commit 剪下貼上的概念，把新增的 commits 都剪下，基於 base 重新製作 coomits。</li>
</ul>
<p>比如說有兩個 branches branch_A，branch_B 共同的 parent 是基於 commit_parent，此時若要用 rebase 方式合併，假設說要 let branch_A rebased on branch_B，則會發現她會把從 commit_parent 之後 branch_A 長出的 commit  一個個剪下，且重新插枝在 branch_B 現在的 commit 上。假設從 commit_parent 之後 branch_A 長出 2 個 commits，那就會將這兩個 commits 剪下，然後 rebased on branch_B，重新製作兩個 commits 插到 branch_B 之後。所以這時候，會看到 branch_A 與 branch_B 在同一條路上了，而且 branch_A 領先 branch_B 2 個 commits。</p>
<p>rebase 完會 branch 會前進，移動到新 commit 上。</p>
<blockquote>
<p>注意: rebase 是修改 commit 歷史的行為。</p>
</blockquote>
<h1 id="cherry-pick">Cherry-Pick</h1>
<p><code>git cherry-pick &lt;commit1&gt; &lt;commit2&gt; &lt;commit3&gt;...</code> 就是去複製某些 commit 重新製作嘗試將改變貼自己身上(HEAD)。</p>
<p>這是一個非常強大的工具，甚至讓你可以重新整理你的整個 branches 之 commits 排列順序等等。</p>
<p>cherry-pick 沒有改變歷史，他是造新的一條 branch 出來。cherry-pick 也會讓 HEAD 以及 branch 移動。</p>
<h1 id="暫存變更">暫存變更</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git stash</code></td>
          <td>暫存當前變更</td>
      </tr>
      <tr>
          <td><code>git stash -m &quot;&lt;message&gt;&quot;</code></td>
          <td>-m 可以註解提供說明訊息</td>
      </tr>
      <tr>
          <td><code>git stash list</code></td>
          <td>列出所有 stash</td>
      </tr>
      <tr>
          <td><code>git stash pop</code></td>
          <td>取回最近一次的 stash，並從列表中移除</td>
      </tr>
      <tr>
          <td><code>git stash pop &quot;stash@{&lt;num&gt;&quot;}</code></td>
          <td>取回編號 num 的 stash，並從列表中移除</td>
      </tr>
      <tr>
          <td><code>git stash apply</code></td>
          <td>取回最近一次的 stash，但不從列表中移除</td>
      </tr>
      <tr>
          <td><code>git stash drop</code></td>
          <td>刪除最近一次的 stash</td>
      </tr>
      <tr>
          <td><code>git stash clear</code></td>
          <td>清除所有 stash</td>
      </tr>
  </tbody>
</table>
<ul>
<li>pop/apply/drop 都可以按照 stash id 選擇存取哪個 stash。</li>
<li>stash id 編號越小越近期的 stash</li>
<li>不論是 worktree 變更或者已經 staged 的變更，都可以被 stash。只不過 pop 回來都會變成是 changes 狀態，不會是 staged 的狀態。</li>
<li>即使 stash 是在比較舊的 commit 上，而 pop 時 HEAD 是在比較新的 commit 上，只要不衝突，依然可以成功 pop 將變更加入。</li>
</ul>
<h1 id="差異比較">差異比較</h1>
<table>
  <thead>
      <tr>
          <th>指令</th>
          <th>說明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>git diff</code></td>
          <td>比較 a.暫存區      與 b.工作區</td>
      </tr>
      <tr>
          <td><code>git diff HEAD</code></td>
          <td>比較 a.當前 commit 與 b.工作區</td>
      </tr>
      <tr>
          <td><code>git diff --staged</code></td>
          <td>比較 a.當前 commit 與 b.暫存區</td>
      </tr>
      <tr>
          <td><code>git diff &lt;commit&gt;</code></td>
          <td>比較 a.某個 commit 與 b.當前 commit</td>
      </tr>
      <tr>
          <td><code>git diff &lt;commit1&gt;..&lt;commit2&gt;</code></td>
          <td>比較 a.commit1     與 b.commmit2</td>
      </tr>
      <tr>
          <td><code>git diff &lt;commit1&gt;..&lt;commit2&gt; -- &lt;file&gt;</code></td>
          <td>比較 a.commit1     與 b.commmit2 間指定檔案之變化</td>
      </tr>
  </tbody>
</table>
<h1 id="基本名詞及概念">基本名詞及概念</h1>
<h2 id="head">HEAD</h2>
<p>HEAD 是一個 reference，他可以指向 branch 也可以直接指向 commit，不管是哪種，它最終都可以推論出一個 commit，表示目前所 checkout 的 commit。</p>
<ol>
<li>HEAD -&gt; branch -&gt; commit</li>
<li>HEAD -&gt; commit</li>
</ol>
<ul>
<li>輸入指令時因為 HEAD 往往已經指向某個 commit，許多針對當前 HEAD 指向之指令就可以不用再指定 commit，非常方便。</li>
<li><code>cat .git/HEAD</code> 可以查詢 HEAD 指向</li>
</ul>
<p>當 HEAD 不是指向 branch 則稱為斷頭(detached head)。</p>
<ul>
<li><code>git checkout &lt;branch&gt;</code> 為 HEAD -&gt; branch -&gt; commit，沒有斷頭。</li>
<li><code>git checkout &lt;commit&gt;</code> 為 HEAD -&gt; commit，就會形成斷頭。</li>
<li><code>git checkout &lt;tag&gt;</code> 為 HEAD -&gt; commit，也會形成斷頭。</li>
</ul>
<h2 id="其他">其他</h2>
<ul>
<li>branch 指向某個 commit，會隨著新的 commit 移動。</li>
<li>remote 是遠端 repository。</li>
<li>upstream 就是某個 branch 其預設 push 的 remote。</li>
<li>commit 指向 root tree object 以及 parent commit。</li>
</ul>
<h1 id="快速定位">快速定位</h1>
<p>依照 HEAD 移動紀錄</p>
<ul>
<li>由 <code>git reflog</code> 可看到 HEAD 的移動紀錄</li>
<li>＠ 可代表 HEAD</li>
<li><code>git checkout &quot;@{1}&quot;</code> 定位 HEAD 的上 1 動之 commit 位址</li>
<li><code>git checkout &quot;@{4}&quot;</code> 定位 HEAD 的前 4 動之 commit 位址</li>
</ul>
<p>依照 commit 指向的第一個父 commit 去回溯。</p>
<ul>
<li>^ 代表「parent（父節點）」，它會指向當前 commit 的 第 1 個父 commit。
<ul>
<li>格式 &ldquo;<!-- raw HTML omitted -->^&rdquo;</li>
<li><code>git checkout &quot;HEAD^&quot;</code> 或者 <code>git checkout &quot;@^&quot;</code></li>
<li><code>git checkout &quot;HEAD^^&quot;</code> 則是往前回溯 2 次。</li>
<li>若 ^ 後面有數字比如 <code>^2</code> 則代表指向當前 commit 的第 2 個父 commit。</li>
</ul>
</li>
<li>~n 代表「向前 n 代的 commit」，相當於不斷往 第一個父 commit 回溯 n 次。
<ul>
<li>格式 &ldquo;<!-- raw HTML omitted -->~n&rdquo;</li>
<li><code>git checkout &quot;HEAD~1&quot;</code> 或者 <code>git checkout &quot;@~1&quot;</code> 或者 <code>git checkout &quot;3bdf7c55~1&quot;</code> 或者 <code>git checkout &quot;main~1&quot;</code></li>
</ul>
</li>
<li>有趣的是移動是可以疊加的，可以
<ul>
<li><code>@^^~^^</code></li>
<li><code>@^^2^^~~</code></li>
<li><code>main^2~3</code></li>
</ul>
</li>
</ul>
<h1 id="git-四大物件">Git 四大物件</h1>
<p>Git 有：<code>blob</code> / <code>tree</code> / <code>commit</code> / <code>tag</code> 四大物件。</p>
<p>每個 git 物件之檔名，均是由內容(不確定是壓縮前或後)及一些其他資訊所計算出的 SHA 值，即使內容只有一個字元差異，也會產生一個新的 git 物件。SHA 的算法很好的用作 ID 表示特定的檔案，且每個檔案名稱長度相同，方便物件關聯檔案控管。</p>
<p>而這些物件的檔案內容則都是壓縮過的，可以用工具還原為未經壓縮之內容。</p>
<p>物件檢視</p>
<ul>
<li><code>git cat-file -t &lt;commit-SHA&gt;</code>  查看物件類型。</li>
<li><code>git cat-file -p &lt;commit-SHA&gt;</code>  還原 Git 物件壓縮前的內容。</li>
</ul>
<p>SHA 值計算
<code>cat &lt;file&gt; | git hash-object --stdin</code> 計算 git 物件之檔案名稱(SHA 值)。</p>
<ol>
<li>Blob 內容是原始檔案內容經過 git 壓縮演算法而成。</li>
<li>Tree 內容指向其他
<ul>
<li>Tree 或</li>
<li>Blob 物件(含 blob 原始檔案之檔名)。</li>
</ul>
</li>
<li>Commit 內容指向
<ul>
<li>git 跟目錄的 Tree 物件</li>
<li>parent commit</li>
<li>commit 訊息</li>
<li>&hellip;</li>
</ul>
</li>
<li>Tag
<ul>
<li>指向一個 commit</li>
</ul>
</li>
</ol>
<p><code>git add</code> 後產生新的 Blob 物件。
<code>git commit</code> 後產生 Tree、commit 物件，把所有物件串起來。</p>
<h1 id="基本設定">基本設定</h1>
<p>設定</p>
<ul>
<li><code>git config --global user.email &lt;email_addr&gt;</code></li>
<li><code>git config --global user.name &lt;username&gt;</code></li>
</ul>
<p>查看設定
<code>git config --global --get user.name</code></p>
<h1 id="初次連接-remote-repo">初次連接 remote repo</h1>
<p>設定 remote 以及 upstream</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git remote add &lt;remote&gt; &lt;remote repository URL&gt;
</span></span><span style="display:flex;"><span>git push -u &lt;remote&gt; &lt;branch&gt;
</span></span></code></pre></div>
        </div>

        
        
      </div>
    </div>
  </div>
</section>





<script>
  var indexURL = "http://localhost:1313/index.json"
</script>

<!-- JS Plugins -->

<script src="http://localhost:1313/plugins/jQuery/jquery.min.js"></script>

<script src="http://localhost:1313/plugins/bootstrap/bootstrap.min.js"></script>

<script src="http://localhost:1313/plugins/search/fuse.min.js"></script>

<script src="http://localhost:1313/plugins/search/mark.js"></script>

<script src="http://localhost:1313/plugins/search/search.js"></script>

<!-- Main Script -->

<script src="http://localhost:1313/js/script.min.js"></script>




<script src="https://cdnjs.cloudflare.com/ajax/libs/js-cookie/2.2.1/js.cookie.min.js"></script>
<div id="js-cookie-box" class="cookie-box cookie-box-hide">
	This site uses cookies. By continuing to use this website, you agree to their use. <span id="js-cookie-button" class="btn btn-sm btn-primary ml-2">I Accept</span>
</div>
<script>
	(function ($) {
		const cookieBox = document.getElementById('js-cookie-box');
		const cookieButton = document.getElementById('js-cookie-button');
		if (!Cookies.get('cookie-box')) {
			cookieBox.classList.remove('cookie-box-hide');
			cookieButton.onclick = function () {
				Cookies.set('cookie-box', true, {
					expires:  2 
				});
				cookieBox.classList.add('cookie-box-hide');
			};
		}
	})(jQuery);
</script>


<style>
.cookie-box {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  text-align: center;
  z-index: 9999;
  padding: 1rem 2rem;
  background: rgb(71, 71, 71);
  transition: all .75s cubic-bezier(.19, 1, .22, 1);
  color: #fdfdfd;
}

.cookie-box-hide {
  display: none;
}
</style>
</body>
</html>